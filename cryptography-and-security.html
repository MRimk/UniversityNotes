<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>cryptography-and-security</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <style>
    html {
      font-size: 100%;
      overflow-y: scroll;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }

    body {
      color: #444;
      font-family: Georgia, Palatino, "Palatino Linotype", Times,
        "Times New Roman", serif;
      font-size: 12px;
      line-height: 1.7;
      padding: 1em;
      margin: auto;
      max-width: 42em;
      background: #fefefe;
    }

    a {
      color: #0645ad;
      text-decoration: none;
    }

    a:visited {
      color: #0b0080;
    }

    a:hover {
      color: #06e;
    }

    a:active {
      color: #faa700;
    }

    a:focus {
      outline: thin dotted;
    }

    *::-moz-selection {
      background: rgba(255, 255, 0, 0.3);
      color: #000;
    }

    *::selection {
      background: rgba(255, 255, 0, 0.3);
      color: #000;
    }

    a::-moz-selection {
      background: rgba(255, 255, 0, 0.3);
      color: #0645ad;
    }

    a::selection {
      background: rgba(255, 255, 0, 0.3);
      color: #0645ad;
    }

    p {
      margin: 1em 0;
    }

    img {
      max-width: 100%;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      color: #111;
      line-height: 125%;
      margin-top: 2em;
      font-weight: normal;
    }

    h4,
    h5,
    h6 {
      font-weight: bold;
    }

    h1 {
      font-size: 2.5em;
    }

    h2 {
      font-size: 2em;
    }

    h3 {
      font-size: 1.5em;
    }

    h4 {
      font-size: 1.2em;
    }

    h5 {
      font-size: 1em;
    }

    h6 {
      font-size: 0.9em;
    }

    blockquote {
      color: #666666;
      margin: 0;
      padding-left: 3em;
      border-left: 0.5em #eee solid;
    }

    hr {
      display: block;
      height: 2px;
      border: 0;
      border-top: 1px solid #aaa;
      border-bottom: 1px solid #eee;
      margin: 1em 0;
      padding: 0;
    }

    pre,
    code,
    kbd,
    samp {
      color: #000;
      font-family: monospace, monospace;
      _font-family: "courier new", monospace;
      font-size: 0.98em;
    }

    pre {
      white-space: pre;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    b,
    strong {
      font-weight: bold;
    }

    dfn {
      font-style: italic;
    }

    ins {
      background: #ff9;
      color: #000;
      text-decoration: none;
    }

    mark {
      background: #ff0;
      color: #000;
      font-style: italic;
      font-weight: bold;
    }

    sub,
    sup {
      font-size: 75%;
      line-height: 0;
      position: relative;
      vertical-align: baseline;
    }

    sup {
      top: -0.5em;
    }

    sub {
      bottom: -0.25em;
    }

    ul,
    ol {
      margin: 1em 0;
      padding: 0 0 0 2em;
    }

    li p:last-child {
      margin-bottom: 0;
    }

    ul ul,
    ol ol {
      margin: 0.3em 0;
    }

    dl {
      margin-bottom: 1em;
    }

    dt {
      font-weight: bold;
      margin-bottom: 0.8em;
    }

    dd {
      margin: 0 0 0.8em 2em;
    }

    dd:last-child {
      margin-bottom: 0;
    }

    img {
      border: 0;
      -ms-interpolation-mode: bicubic;
      vertical-align: middle;
    }

    figure {
      display: block;
      text-align: center;
      margin: 1em 0;
    }

    figure img {
      border: none;
      margin: 0 auto;
    }

    figcaption {
      font-size: 0.8em;
      font-style: italic;
      margin: 0 0 0.8em;
    }

    table {
      margin-bottom: 2em;
      border-bottom: 1px solid #ddd;
      border-right: 1px solid #ddd;
      border-spacing: 0;
      border-collapse: collapse;
    }

    table th {
      padding: 0.2em 1em;
      background-color: #eee;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
    }

    table td {
      padding: 0.2em 1em;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
      vertical-align: top;
    }

    .author {
      font-size: 1.2em;
      text-align: center;
    }

    @media only screen and (min-width: 480px) {
      body {
        font-size: 14px;
      }
    }
    @media only screen and (min-width: 768px) {
      body {
        font-size: 16px;
      }
    }
    @media print {
      * {
        background: transparent !important;
        color: black !important;
        filter: none !important;
        -ms-filter: none !important;
      }

      body {
        font-size: 12pt;
        max-width: 100%;
      }

      a,
      a:visited {
        text-decoration: underline;
      }

      hr {
        height: 1px;
        border: 0;
        border-bottom: 1px solid black;
      }

      a[href]:after {
        content: " (" attr(href) ")";
      }

      abbr[title]:after {
        content: " (" attr(title) ")";
      }

      .ir a:after,
      a[href^="javascript:"]:after,
      a[href^="#"]:after {
        content: "";
      }

      pre,
      blockquote {
        border: 1px solid #999;
        padding-right: 1em;
        page-break-inside: avoid;
      }

      tr,
      img {
        page-break-inside: avoid;
      }

      img {
        max-width: 100% !important;
      }

      @page :left {
        margin: 15mm 20mm 15mm 10mm;
      }

      @page :right {
        margin: 15mm 10mm 15mm 20mm;
      }

      p,
      h2,
      h3 {
        orphans: 3;
        widows: 3;
      }

      h2,
      h3 {
        page-break-after: avoid;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/darkreader@4.7.15/darkreader.min.js"></script>
  <script>
    DarkReader.enable({
      brightness: 100,
      contrast: 90,
      sepia: 10,
    });
  </script>
  <link
    rel="icon"
    type="image/png"
    href="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcTJg97A-Sa8mxjkRCmjR51WjHATLvq2aF89Z1CprR2WcQ60qYZC"
  />
  <meta name="theme-color" content="#252525" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#ancient-cryptography"
id="toc-ancient-cryptography">Ancient cryptography</a>
<ul>
<li><a href="#scope-of-cyptography" id="toc-scope-of-cyptography">Scope
of Cyptography</a></li>
<li><a href="#notions" id="toc-notions">Notions</a></li>
<li><a href="#secure-communication-problems"
id="toc-secure-communication-problems">Secure communication
problems</a></li>
<li><a href="#symmetric-encryption"
id="toc-symmetric-encryption">Symmetric encryption</a></li>
<li><a href="#establishing-symmetric-key---key-agreement-protocol"
id="toc-establishing-symmetric-key---key-agreement-protocol">Establishing
Symmetric key - Key Agreement Protocol</a></li>
<li><a href="#public-key-cryptosystem"
id="toc-public-key-cryptosystem">Public-key cryptosystem</a></li>
<li><a href="#digital-signature" id="toc-digital-signature">Digital
signature</a></li>
<li><a href="#example-of-tls-slide-24"
id="toc-example-of-tls-slide-24">Example of TLS (slide 24)</a></li>
</ul></li>
<li><a href="#prehistory" id="toc-prehistory">Prehistory</a>
<ul>
<li><a href="#techniques" id="toc-techniques">Techniques</a></li>
</ul></li>
<li><a href="#pre-modern-industrial-cyptography"
id="toc-pre-modern-industrial-cyptography">Pre-Modern Industrial
Cyptography</a>
<ul>
<li><a href="#enigma" id="toc-enigma">Enigma</a></li>
</ul></li>
<li><a href="#laws-of-modern-cryptography"
id="toc-laws-of-modern-cryptography">Laws of Modern Cryptography</a>
<ul>
<li><a href="#law-1-the-kerckhoffs-principle"
id="toc-law-1-the-kerckhoffs-principle">Law 1: the Kerckhoffs
Principle</a></li>
<li><a href="#law-2-scalability---the-n2-problem"
id="toc-law-2-scalability---the-n2-problem">Law 2: scalability - the n^2
problem</a></li>
<li><a href="#law-3-moore-law" id="toc-law-3-moore-law">Law 3: Moore
law</a></li>
<li><a href="#bit-key" id="toc-bit-key">128-bit key</a></li>
</ul></li>
<li><a href="#two-revolutions" id="toc-two-revolutions">Two
Revolutions</a></li>
<li><a href="#xor" id="toc-xor">XOR</a>
<ul>
<li><a href="#vernam-cipther" id="toc-vernam-cipther">Vernam
cipther</a></li>
<li><a href="#information-theory"
id="toc-information-theory">Information theory</a></li>
<li><a href="#perfect-secrecy" id="toc-perfect-secrecy">Perfect
Secrecy</a></li>
</ul></li>
<li><a href="#diffie-hellman-cryptography"
id="toc-diffie-hellman-cryptography">Diffie-Hellman Cryptography</a>
<ul>
<li><a href="#arithmetics-on-z_n"
id="toc-arithmetics-on-z_n">Arithmetics on <span
class="math inline">\Z_n</span></a></li>
<li><a href="#diffie-hellman-key-agrreement-protocol"
id="toc-diffie-hellman-key-agrreement-protocol">Diffie-Hellman Key
Agrreement Protocol</a></li>
<li><a href="#algorithms-for-big-numbers"
id="toc-algorithms-for-big-numbers">Algorithms for Big Numbers</a></li>
<li><a href="#z_n---ring-of-residues-modulo-n"
id="toc-z_n---ring-of-residues-modulo-n"><span
class="math inline">\Z_n</span> - Ring of Residues Modulo n</a></li>
<li><a href="#z_p-field" id="toc-z_p-field"><span
class="math inline">\Z_p</span> Field</a></li>
<li><a href="#diffie-hellman-key-agreement-protocol"
id="toc-diffie-hellman-key-agreement-protocol">Diffie-Hellman key
agreement protocol</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">Exercises 3</a></li>
<li><a href="#unavoidable-active-attack---mitm"
id="toc-unavoidable-active-attack---mitm">Unavoidable Active Attack -
MITM</a></li>
<li><a href="#correct-dh-key-exchange"
id="toc-correct-dh-key-exchange">Correct DH key exchange</a></li>
<li><a href="#standard-rfc-2631" id="toc-standard-rfc-2631">Standard RFC
2631</a></li>
<li><a href="#elgamal-public-key-cryptosystem"
id="toc-elgamal-public-key-cryptosystem">ElGamal Public key
cryptosystem</a></li>
</ul></li>
<li><a href="#rsa-cryptography" id="toc-rsa-cryptography">RSA
Cryptography</a>
<ul>
<li><a href="#euler-totient-function"
id="toc-euler-totient-function">Euler Totient Function</a></li>
</ul></li>
</ul>
</nav>
<!-- markdownlint-disable MD010 MD041 MD001 MD036 MD029-->
<h2 id="ancient-cryptography">Ancient cryptography</h2>
<h3 id="scope-of-cyptography">Scope of Cyptography</h3>
<p>Now it is basically any device that uses some encoding.</p>
<p>In prehistory it was to preserve confidentiality/privacy.</p>
<p>Modern cryptography is public and interceptable, so confidentiality
is a problem. The main problem of modern telephony is authetication of
the user/access control. There are also problems such as detection of
malicious modificaiton, data authetification, non-repudiation (no
stepping back/denying a completed action), access control, timestamping,
fair exchange, etc.</p>
<h3 id="notions">Notions</h3>
<p>The differenece between coding and cryptography is that crypto has
malicious adversary whereas coding has some noise or nature that could
affect reliable communication (= dummy adversary).</p>
<p>Cryptanalysis is a theory of security analysis of cryptography
systems.</p>
<p>To cryptanalyze a cryptosystem means to probe or to disprove the
security (but does not necessarily mean to break it). Breaking is just
proving the insecurity.</p>
<h3 id="secure-communication-problems">Secure communication
problems</h3>
<ol type="1">
<li>Nobody else can read the message (sent over an insecure channel) -
confidentiality</li>
<li>Receiver must get the same message (integrity) as it was sent by the
sender</li>
<li>Only the right receiver should get the message -
authetification</li>
</ol>
<h3 id="symmetric-encryption">Symmetric encryption</h3>
<p>Assume: confidentiality.</p>
<p>Sender will use same key to compute MAC (message authentification
code) and the receiver will decode the MAC. This ensures
authentification and integrity.</p>
<p>Symmetric encryption algorithms are very efficient and quick.</p>
<p>Problem is to have the same key.</p>
<h3
id="establishing-symmetric-key---key-agreement-protocol">Establishing
Symmetric key - Key Agreement Protocol</h3>
<p>Key should be made sure that it comes from the right receiver (is not
modified, not known to adversary).</p>
<p>Only assume authetication, integrity. Because the confidentiality
does not necessarily matter during the exchange.</p>
<h3 id="public-key-cryptosystem">Public-key cryptosystem</h3>
<p>Assume authentication and integrity so that it is not replaced by the
adversary.</p>
<p>Receiver creates generator to give public key to sender.</p>
<p>Receiver uses secret to decode the message that is encrypted by their
pub key.</p>
<h3 id="digital-signature">Digital signature</h3>
<p>It is the reversed PK cryptosystem. Server signs the message with
their secret and receiver verifies message with the sender’s pub
key.</p>
<p>Assume pub key is transfered in autheticated and integrity preserved
channel.</p>
<h3 id="example-of-tls-slide-24">Example of TLS (slide 24)</h3>
<p>Browser already has some authorities.</p>
<p>When server is created it sends its pub key to CA to sign it, and
then server sends the message to client signed with its private key.
Client verifies message with authority-given server’s public key
(authority signs the public key).</p>
<h2 id="prehistory">Prehistory</h2>
<p>Hieroglyphs were understood only by some people.</p>
<h3 id="techniques">Techniques</h3>
<h4 id="transpositions">Transpositions</h4>
<p>e.g. Spartan scytacles which reorders the message letters such that
it is known by some key (stick with a belt)</p>
<h4 id="substitutions">Substitutions</h4>
<p>e.g. Caesar cipher (letter is moved in an alphabet), ROT13 (shifted
by 13 positions, so it is half of alphabet), random substitution table -
a lot of permutations 26! - to break this we can do frequency analysis
on 1, 2, or 3 consecutive letters.</p>
<h4 id="continuous-permutation">Continuous permutation</h4>
<p>Vigenere cipher - take a message without spaces and take a key
(e.g. ABC) and continuously apply to each letter. E.g. “this” + “ABC” =
t+0, h+1, i+2, s+0. One of the first cyphers with a secret key. The
continuous permutation messes up the statistical analysis.</p>
<ul>
<li>column-dependent substitution - write out the message into the
key-length amount of columns and then apply statistical analysis.</li>
<li>Also statistical analysis - if there is a repeating trigram.
(e.g. 313 chars, 26 possible letters, 5 occurances of same trigram).
Calculation of k-tuples of elements in a set of size z: z^k. Number of
possible subsets of t elements in a set of size n: nCt. This leads to
binomial distribution: probability to pick the same item u exactly t
times that has a probability p is nCt * p^t * (1-p)^(n-t). So there are
n=311 (length - 2)possible trigrams. Each trigram has an independent
probability of appearing 1/p = 26^3 = 17576. Approximate binomial
distribution wiht poisson’s distribution because n * p is small, and we
get that the probability to get 5 occurances is very low. The
differences of occurance locations are multiples of 5, so the key should
be 5. So it is 5 columns.</li>
<li>Index of Coincidence can also be used. The formula is sum c in Z
nc(nc-1)/n(n-1)</li>
<li>Expected Index of Coincidence - Sum c in Z fc^2 if all xi have
independent distrbution with frequency table fc</li>
<li>Index of column can be used to verify a guess of the key length
(language should be known because it differs). Index in English as n
-&gt; inf, is -&gt; 0.065, so if it close for the column, then we know
that the key length is correct</li>
</ul>
<h2 id="pre-modern-industrial-cyptography">Pre-Modern Industrial
Cyptography</h2>
<h3 id="enigma">Enigma</h3>
<p>Electro-mechanical encryption device (typewriter) which could be
plugged into radio transmiter.</p>
<p>It was patented in 1918, so the information about the device was
public, but the secret was inputted in the device to encrypt
information.</p>
<p>It was used by the German army WW2.</p>
<p>There were preliminary attacks by polish mathematician Rejewski in
1932 but then they were invaded, so transfered information to France,
which was also invaded, so it was transfered to UK.</p>
<p>There was an “industrial” attack from Bletchley Park (~2000 messages
per day) during WW2. They built computers to automatize breaking the
messages, because mathematics were understood but required a lot of
checking.</p>
<p>The key is connected to the plugboard plug, and then the signal goes
to the rotors (through 1st, 2nd, 3rd, 3rd, 2nd, 1st), and back to
plugboard, back to the light. Each time the key is pressed, the rotor
will move. First rotos moves with each letter, 2nd every full 1st
rotation, etc.</p>
<p>Encryption and decryption is symmetric as long as you start from the
same condition (due to electrical signal symmetry (N.B. my idea))</p>
<p>Initial state is the key. There are 5 different rotors available, so
the 3 chosen rotors and their starting positions, and wires plugged in
the plugboard.</p>
<h4 id="definitions">Definitions</h4>
<p>Fixed point - Given a permution sigma over Z, a fixed point is an
element x in Z such that sigma(x) = x (no change)</p>
<p>Involution over Z is a permutation sigma of Z such that
sigma(sigma(x)) = x for all x. (so the reflector after last rotor is
that, plugboard is that)</p>
<p>Rotor sigma defines a set of sermutations sigma0, …, sigma25 over Z.
The rotor in position i implements permutation sigmai, such that sigmai
= p^i o sigma o p^-i</p>
<p>Secret key:</p>
<ul>
<li>sigma (involution made of 6 pairs)</li>
<li>ordered choice of alpha, beta gamma in S of pairwise different
permutations</li>
<li>a number a</li>
</ul>
<p>Encryption: <span class="math inline">y_i = σ_{−1} ◦ α_{i−1} ◦
β_{i−1} ◦ γ_{i−1} ◦ π ◦ γ_{i3} ◦ β_{i2} ◦ α_{i1} ◦ σ_{xi}</span> where
i3 i2 i1 are the last three digits of the basis 26 numeration of i +
a.</p>
<p>Key entropy of Enigma:</p>
<p>Number of involutions: 26 C 14 * 11 * 9 * 7 * … * 1 ~= 2^37 (14 is
fixed points are the leftover plugs that are not connected by the 6
cables) (11 is available positions to connect the other end of the
cable, then 9, then 7, then …)</p>
<p>Number of choices for the rotors: 5 * 4 * 3 = 60</p>
<p>Number of initial positions: 2^14</p>
<p>It is 57 bits.</p>
<h2 id="laws-of-modern-cryptography">Laws of Modern Cryptography</h2>
<h3 id="law-1-the-kerckhoffs-principle">Law 1: the Kerckhoffs
Principle</h3>
<p>Security should not rely on the secrecy of the cryptosystem
itself</p>
<p>WHY? - the adversary may get some information about the system
(e.g. reverse engineer) WHAT DOES IT MEAN? - security analysis starts
with the assumption that adversary knows the cryptosystem DOES NOT MEAN
- cryptosystem must be public.</p>
<h3 id="law-2-scalability---the-n2-problem">Law 2: scalability - the n^2
problem</h3>
<p>in a network of n users, there is a number of potential pairs of
users within the order of magnitude of n^2</p>
<p>We cannot assume that every pair of users share a secret key We must
find a way for any pair of users to establish a secret key</p>
<h3 id="law-3-moore-law">Law 3: Moore law</h3>
<p>the speed of CPUs doubles ever 18-24 months.</p>
<p>We should wonder how long a system must remain secure We must
estimate the speed of CPU at the end of its period</p>
<h3 id="bit-key">128-bit key</h3>
<p>Possible key combinations - 2^128 (39 digit number)</p>
<p>It is impossible to do an exchaustive search.</p>
<p>In 2007, a standard PC could test 10^6 keys per second To run
exhaustive search within 14 billion years we need 770 000 bilion
2007-PCs</p>
<p>if the Moore law goes on, a single 2215-PC will do it in a second</p>
<h2 id="two-revolutions">Two Revolutions</h2>
<p>Communication - information theory, mass communication (radio) -&gt;
we need standard crypto</p>
<p>Computing - computer science, automata -&gt; adversaries have more
power</p>
<h2 id="xor">XOR</h2>
<p>Bit-wise exclusive or.</p>
<p>Due to its properties forms a commutative group.</p>
<h3 id="vernam-cipther">Vernam cipther</h3>
<p>Message is passed through a key with xor, and then decrypted with the
same key with xor. <span class="math inline">(X \oplus K) \oplus K = X
\oplus (K \oplus K)</span></p>
<p>This cipher was tried to be published in 1918 (only published in
1926), because it was deemed that the WW is over.</p>
<p>We use a uniformly distributed random key K. Every message X requires
a new K of same size (one-time pad)</p>
<p>Q: When is it insecure?</p>
<ol type="1">
<li>When using the same key twice: <span class="math inline">Y_1 = X_1
\oplus K</span> and <span class="math inline">Y_2 = X_2 \oplus K</span>.
We xor those numbers and we get (by applying distributivity and
commutativity) xor of plaintext: <span class="math inline">Y_1 \oplus
Y_2 = X_1 \oplus X_2</span>. The same way it could be used for visual
cryptography. And in visual crypto it can be seen clearer why it is
possible to deduce what are those plaintexts (plain images) when they
are xor’ed.</li>
<li>if K is smaller than X. only the left part wil be encrypted and the
right part will stay the same.</li>
<li>if K is not uniformly distributed. <span class="math inline">Pr[K =
k] high \implies Pr[X = y \oplus k] high</span></li>
</ol>
<p>Due to one-time use, in most cases it does not make sense to use
this. But provides perfect security</p>
<p>Makes sense to prepare emergency communication (red telephone) - keys
are exchanged (through slow channels) before the messages to transmit
are known</p>
<p>bad news for other applications - there is essentially no better
cipher with this strong security property</p>
<h4 id="intuition-on-perfect-security">Intuition on perfect
security</h4>
<p>if the adversary gets Y = y then for any x: <span
class="math display">Pr[X = x | Y = y] = Pr[X = x | X \oplus K = y] =
Pr[X = x]</span></p>
<p>because <span class="math inline">X</span> and <span
class="math inline">X \oplus K</span> are statisticaly independent <span
class="math inline">\implies</span> the adversary gets no information
about X in knowing that Y = y</p>
<h4 id="abelian-group">Abelian group</h4>
<p>Set of G together with a mapping from G x G to G which maps (a,b) to
an element denoted a + b</p>
<ol type="1">
<li>[closure]</li>
<li>[associativity]</li>
<li>[neutral element]</li>
<li>[invertability]</li>
<li>[commutativity] (only in Abelian groups)</li>
</ol>
<p>E.g. <span class="math inline">\Z</span> with regular addition <span
class="math inline">\{0, 1\}^2</span> with <span
class="math inline">\oplus</span> <span
class="math inline">\{0,1,...,n-1\}</span> with <span
class="math inline">(a,b) \rightarrowtail \begin{cases}  a+b\ \text{if}\
a+b &lt; n \\  a+b-n\ otherwise \end{cases}</span></p>
<h4 id="useful-lemma-to-prove-security">Useful lemma to prove
security</h4>
<p><strong>Lemma</strong>: Let X and K be two independent random
variables in a given group. If K is uniformly distributed, then Y = K +
X is uniformly distributed and independent from X.</p>
<p><strong>Proof</strong> For any x and y: <span
class="math display">Pr[X = x, Y = y] = Pr[X = x, K = y - x]</span></p>
<p><span class="math display">= Pr[X=x] \times Pr[K = y - x]</span></p>
<p><span class="math display">= Pr[X=x] \frac{1}{\# group}</span></p>
<p><span class="math display">Pr[Y=y] = \sum_x Pr[X=x, Y=y] =
\frac{1}{\# group}</span></p>
<h4 id="theorem">Theorem</h4>
<p><strong>Theorem</strong> - For any distribution of X over G, Y is
independent from X and uniformly distributed (perfect secrecy)</p>
<h3 id="information-theory">Information theory</h3>
<p>Entropy - (used in this course) number of bits. But there is the
Shannon Entropy - amount of information you have in a random
variable.</p>
<h3 id="perfect-secrecy">Perfect Secrecy</h3>
<p><strong>Definition</strong>: Perfect secrecy means that the a
posteriori distribution of the plaintext of X after we know the
ciphertext Y is equal to the a priori distribution of the plaintext:
<span class="math inline">\forall x,y \ Pr[Y=y] \ne 0 \implies Pr[X=x |
Y =y] = Pr[X=x]</span></p>
<p>Also, perfect secrecy is equivalent to statistic independence of X
and Y Or, is equivalent to H(X|Y) = H(X)</p>
<p><strong>Theorem</strong>: For any distribution of the plaintext, the
generalized Vernam cipher provides perfect secrecy.</p>
<p><strong>Shannon theory</strong> - perfect secrecy implies <span
class="math inline">H(K) \ge H(X)</span> Or: Perfect secrecy implies
that the support of K is at least as large as the support of X.</p>
<h4 id="negative-side-of-shannon-theorem">Negative side of Shannon
Theorem</h4>
<p>If we want ot achieve perfect secrecy, the number of possible keys
must be at least as large as the number of possible plaintexts</p>
<p><strong>Theorem</strong>: perfect secrecy implies that X has a finite
support. <span class="math inline">\#support(X) \le \frac{1}{p}</span>,
where <span class="math inline">p = Pr [Y=y] \ne 0</span></p>
<p>Intuition - length of the cipher text will give some information on
the plaintext. E.g. 1TB plaintext will be represented by approx 1TB
ciphertext</p>
<h4 id="summary-of-shannon-results">Summary of Shannon results</h4>
<p>We have mathematically formalized the notion of perfect strategy
Vernam Cipher achieves perfect secrecy Despite Vernam Cipher is
expensive, there is no cheaper alternative.</p>
<p>The <strong>Complexity theory</strong> is missing, since the perfect
secrecy is impractical.</p>
<h2 id="diffie-hellman-cryptography">Diffie-Hellman Cryptography</h2>
<h3 id="arithmetics-on-z_n">Arithmetics on <span
class="math inline">\Z_n</span></h3>
<p><strong>Theorem</strong> - every integer n can be uniquely writen as
a unit times product of prime numbers $n = u p^{_1}_1 … p^{_r}_r $.
Where <span class="math inline">u = \plusmn 1</span></p>
<p>Two notations of “mod”:</p>
<ul>
<li>w/o parenthesis x mod n is an operation</li>
<li>with parenthesis <span class="math inline">a \equiv b (mod\
n)</span> is an equivalence relation.</li>
</ul>
<p><span class="math inline">\Z_n = \{0, 1, ..., n-1\}</span> Addition:
$a b = (a+b) mod n $ Multiplication: <span class="math inline">a
\boxtimes b = (a \times b)\ mod\ n</span> Both are associative, closed,
has neutral elements, invertable (for <span
class="math inline">\boxplus</span>) and distributed. Notation can be
<span class="math inline">\Z/n\Z</span></p>
<p><strong>Abelian group</strong> is a group that also has
commutativity.</p>
<p><strong>Group homomorphism</strong> - given two groups <span
class="math inline">(G_1, \times_1)</span> and <span
class="math inline">(G_2, \times_2)</span> a mapping f from <span
class="math inline">G_1</span> to <span class="math inline">G_2</span>
is a group homomorphism if for any <span class="math inline">a, b \in
G_1</span>: <span class="math inline">f(a \times_1 b) = f(a) \times_2
f(b)</span> <strong>Isomorphism</strong> - group homomorphism which is
bijective is called an isomorphism. <em>ismorphism = change pf
notation</em></p>
<p><strong>Subroupts theorem</strong> - if H is a subgroup of <span
class="math inline">\Z</span> and <span class="math inline">H \ne
\{0\}</span>, then <span class="math inline">H = n\Z</span> where n is
the smallest positive element of H. Proof:</p>
<ul>
<li>let <span class="math inline">a \in H</span> and write <span
class="math inline">a = qn + r</span> with <span class="math inline">q,
r \in \Z</span> and <span class="math inline">0 \le r &lt; n</span>
(Euclidean division)</li>
<li>since H is a group and <span class="math inline">a, n \in H</span>
we have <span class="math inline">r = a - qn \in H</span></li>
<li>since <span class="math inline">0 \le r &lt; n</span> nad n is the
smallest positive element of H, we must have r = 0, thus <span
class="math inline">a = qn \in n\Z</span></li>
<li>therefore <span class="math inline">H \subset n\Z</span></li>
<li>conversely, rn must be in H for all <span class="math inline">r ∈
\Z</span>, therefore <span class="math inline">H = n\Z</span></li>
</ul>
<p><strong>Generator</strong> - givent a group (G,.)m an element g
generates/spans a <span class="math inline">\langle g \rangle = \{...,
g^{-2}, g^{-1}, g^0, g^1, ...\}</span></p>
<p><strong>Definition</strong> If (G,.) is a group and if G is a finite
set, then the cardinality of G is called the group
<strong>order</strong>. If g generates a subgroup of order n, then n is
colled the order of g</p>
<p><strong>Preposition</strong> - the order of g is the smallest i &gt;
0 s.t. <span class="math inline">g^i = 1</span> Proof:</p>
<ul>
<li>the set of all <span class="math inline">i \in \Z</span> s.t. <span
class="math inline">g^i = 1</span> is a subgroup of <span
class="math inline">\Z</span> (preimage of subgroup {1} by group
homomorphism <span class="math inline">i \rightarrowtail
g^i</span>)</li>
<li>it must be of form <span class="math inline">n\Z</span> where n is
the smallest among all i &gt; 0</li>
<li><span class="math inline">\{1, g, g^2, ..., g^{n-1}\}</span> is a
non-repeating exhaustive list of all <span class="math inline">\langle g
\rangle</span> elements.</li>
</ul>
<p><em>Consequence</em> if g is of order n:</p>
<ul>
<li><span class="math inline">\langle g \rangle = \{..., g^{-2}, g^{-1},
g^0, g^1, ...\}</span></li>
<li><span class="math inline">\forall i g^i = 1 \lrArr n|i</span></li>
<li><span class="math inline">\forall i,j\ g^i = g^j \lrArr i \equiv j
(mod\ n)</span></li>
</ul>
<p><strong>Power group</strong> given <span class="math inline">(G,
*)</span> and I, consider <span class="math inline">G^I</span> and <span
class="math inline">(a*i)_{i \in I} \times (b*i)_{i \in I} = (a_i *
b_i)_{i \in I}</span></p>
<p><strong>Quotient Group</strong> - given a commutative group G and a
subgroup H, consider the set G/H of classes for congruence module H with
the law induced by +.</p>
<ul>
<li>a and b in G are said to be congruent modulp H if <span
class="math inline">b -a \in H</span>, notation <span
class="math inline">a \equiv b (mod\ H)</span></li>
<li>the relation “… is congruent to … modulo H” is an equivalence
relation (refl, sym, trans)</li>
<li>notation: for <span class="math inline">a \in G, a+H</span> is the
set of all G elemenet which can be written as <span
class="math inline">a +h</span> for some <span class="math inline">h \in
H</span> (elements congruent to a)</li>
<li>every class of equivalence can be written as <span
class="math inline">a + H</span> for some <span class="math inline">a
\in G</span> a is called <em>representative</em> for the class</li>
</ul>
<p>Quotient example: Z/6Z <span class="math inline">Z/H = \{H, 1+H, 2+H,
3+H, 4+H, 5+H\}</span></p>
<p><strong>Lagrange theorem</strong> - in any finite group, the order of
any element is a factor of the order of the group. <em>Consequence</em>:
<span class="math inline">\forall g \in G\ g^{\#G} = 1</span></p>
<p><strong>Theorem</strong> - if a group has a prime order, all elements
(except 1) are generators.</p>
<h3 id="diffie-hellman-key-agrreement-protocol">Diffie-Hellman Key
Agrreement Protocol</h3>
<p>Assume a group generated by some g (g is public)</p>
<p>Alice picks x at random, X is <span class="math inline">g^x</span>,
sends x to Bob. Bob picks y at random, computes Y is <span
class="math inline">g^y</span>, sends y to Alice. Alice uses <span
class="math inline">K = Y^x</span>, Bob uses <span class="math inline">K
= X^y</span> <span class="math inline">(K = g^{xy})</span></p>
<p>security requirement: given <span class="math inline">(g, g^x,
g^y)</span>, it must be hard to compute <span
class="math inline">g^{xy}</span> (<strong>Computational Diffie-Hellman
Problem</strong>)</p>
<h4 id="using-the-diffie-hellman-key-agreement-protocol">Using the
Diffie-Hellman key agreement protocol</h4>
<p>Allows to set up a secret key over a public channel (assumening
authetification)</p>
<p>No further need to set up pre-shared keys: sets up keys when needed
-&gt; pub key cryptography</p>
<h3 id="algorithms-for-big-numbers">Algorithms for Big Numbers</h3>
<p><strong>Monoid</strong> is a set group without invertability.</p>
<p>We want to multiple a monoid element (a = 12) by an integer (n =
100101 in binary): 12 x 100101 - we use powers of 2. Multiplication by 2
consistes of additing ot itself - multiplication by 2^i consists of
multiplying i times by 2.</p>
<p>Double-and-add from left to right or right to left is O(l) complexity
of monoid additions.</p>
<p>The equivalent for squaring is multiplying.</p>
<h3 id="z_n---ring-of-residues-modulo-n"><span
class="math inline">\Z_n</span> - Ring of Residues Modulo n</h3>
<p>Ring has Abelian group properties as well as closure, associativity,
neutral element, distributivity, and commutative rings have
commutativity.</p>
<p>Group of units:</p>
<ul>
<li>not every element x in a ring R has an inverse for the
multiplication</li>
<li>we denote R* the set of elements having a multiplicative inverse,
which are <strong>units</strong></li>
<li>group of units is denoted as R*</li>
</ul>
<p>subgroup - subset of a group stable by group law and inversion. Ideal
- subgroup of a ring stable by multiplication by any ring element.</p>
<p>Spanned structure - set of all values generated by structure
operations</p>
<p>product structure - set of pairs with inverited structure
operations</p>
<h4 id="z-is-a-commutative-ring"><span class="math inline">\Z</span> is
a commutative ring</h4>
<h4 id="example-zx">Example: <span class="math inline">\Z[X]</span></h4>
<p>Z[X] is a set of polynomials with coefficients in Z.</p>
<p>It is a commutative ring, with neutral element would be 0.</p>
<h4 id="verifying-multiplication">Verifying multiplication</h4>
<p>Sum of first number of digits mod 9 times sum of second number digits
mod 9, is the product digits sum mod 9.</p>
<p>Mod 9 works because 10 to any power reduces to 1.</p>
<h4 id="example-the-ring-of-resudues-mod-n">Example: the ring of
resudues mod n</h4>
<p><span class="math inline">Z_n = \{0, 1, 2, 3, ... , n-1\}</span></p>
<p>Cerebral <span class="math inline">\Z n</span>:</p>
<ul>
<li>nZ is an ideal of Z (with laws mult and add)</li>
<li>we can do the quotient Z/nZ of Z by nZ</li>
<li>congruence modulo nZ is written: <span class="math inline">a \equiv
b (mod n) \lrArr a\ mod\ n = b\ mod\ n</span></li>
</ul>
<p><span class="math inline">Z_n</span> tips:</p>
<ul>
<li>for any polynomial P(x) in Z[x] and any a, n in Z we have <span
class="math inline">P(a) mod\ n = P(a\ mod\ n) mod\ n</span> - we can
put “mod n” reductions in the ground floor.</li>
<li>if x has order m in Zn* then for any i in Z: <span
class="math inline">x^i\ mod\ n = x^{i\ mod\ m} mod\ n</span>, so we can
put “mod m” reductions in the upper floor.</li>
</ul>
<h5 id="exercise">Exercise</h5>
<p><span class="math inline">Z_{15}</span> has order 15.</p>
<ul>
<li>we have <span class="math inline">\langle 5\rangle = \{0, 5,
10\}</span>
<ul>
<li>this is a subgroup of order 3</li>
<li>6 has order 3 in <span class="math inline">Z_{15}</span></li>
</ul></li>
<li>in <span class="math inline">Z_{15}</span>: <span
class="math inline">\langle 2\rangle = \{0, 2, 4, 6, 8, 10, 12, 14, 1,
3, 5, 7, 9, 11, 13\}</span>
<ul>
<li>2 has the order 15, so 2 is a generator</li>
</ul></li>
<li>we have <span class="math inline">\langle 1\rangle =
Z_{15}</span></li>
<li><span class="math inline">Z_{15}^* = \{1,2,4,7,8,11,13,14\}</span>
(3 is not there because it is not invertible because (3r - 15q = 3r mod
15 <span class="math inline">\ne</span> 1), same is for 5 and 6.
Intuition 3 and 5 are factors of 15)</li>
<li>in <span class="math inline">Z_{15}^*</span> 2 has the order 4:
<span class="math inline">\langle 2\rangle = \{0, 2, 4, 6,
8\}</span></li>
</ul>
<h4 id="z_n-computations"><span class="math inline">Z_n</span>
computations</h4>
<p>Efficiently computable operations:</p>
<ul>
<li>addtion: (a+b) mod n</li>
<li>multiplication: (a * b) mod n (double-and-add)</li>
<li>modulo: a mod n (Euclidian division)</li>
<li>inverse: <span class="math inline">a^{-1} mod\ n</span> when gcd(a,
n) = 1</li>
<li>power: <span class="math inline">a^e</span> mod n (for e integer
only) (square-and-multiply)</li>
</ul>
<p>And remaining problem is extracting the roots</p>
<h5 id="euclidean-division">Euclidean division</h5>
<p>x = qy + r algorithm runs in <span
class="math inline">O(l^2)</span></p>
<h5 id="modular-inversion">Modular Inversion</h5>
<p><strong>Theorem</strong> x in <span class="math inline">Z_n</span> is
inveritible if and only if gcd(x,n) = 1. (this is why 3, 5 were not
inverses in Z15)</p>
<p><strong>Euclid algorithm</strong> is used to calculate gcd. Why does
it work? - Why does it terminate? - Euclidean division and subtraction
decreases the number so it will become 0 at some point. Why does it come
out with GCD? - set of common dividers of initial numbers is the same as
next step euclidean algorithm numbers.</p>
<p>Running time is quadratic to the length of numbers in bits</p>
<p><strong>Extended Euclid algorithm</strong> is used to calculate d, u,
v, that d = au + bv = gcd(a,b).</p>
<h4 id="orders-of-group">Orders of group</h4>
<p><strong>Element order</strong>: n is the smallest positive such that
<span class="math inline">x^n = 1</span> n is such that <span
class="math inline">x^i = 1 \lrArr (n \text{ divides } i)</span></p>
<p><strong>Group order</strong>: <span class="math inline">G = \{i ∈ Z;
∀x ∈ G\ x^i = 1\}</span> <span class="math inline">\lambda</span> is
called the exponent of G, where it is the smallest positive such that
<span class="math inline">\forall x \in G, x^\lambda = 1</span> Note:
<span class="math inline">\#G \in \lambda Z</span> so <span
class="math inline">\lambda</span> is a factor of #G, so <span
class="math inline">\forall x \in G \text{ order(x) }| \lambda |
\#G</span> λ is the lcm of all order(x), x ∈ G</p>
<p><strong>Orders in <span class="math inline">Z_m^*</span></strong>
<span class="math inline">Z_m^*</span> is of order φ(m) (example: <span
class="math inline">Z_35^*</span> is of order 24) <span
class="math inline">Z_m^*</span> is of exponent λ(m) (example: <span
class="math inline">Z_35^*</span> is of exponent 12)</p>
<p>for <span class="math inline">m = p_1^{α_1} × · · · ×
p_r^{α_r}</span> with pairwise different prime numbers <span
class="math inline">p_1 , . . . , p_r</span> , we have</p>
<p>φ(m)=(p1 − 1)p1α1 −1 × · · · × (pr − 1)prαr −1 λ(m)= lcm λ(p1α1 ), ·
· · , λ(prαr )</p>
<p><strong>application</strong>: if n is hard to factor, we can still
find generators: find prime factors up to some bound B</p>
<h4 id="picking-a-generator-in-a-cyclic-group-with-known-order">Picking
a generator in a cyclic group with known order</h4>
<p>This algorith is probabilistic with a bound of <span
class="math inline">\text{Pr[output g not generator]} \le \frac{1}{B\log
B}\log B</span></p>
<p><span class="math inline">\text{Pr[not generator | passed]} \le
\frac{1}{B}(r-s) \le \frac{\log q}{B\log B} \le \frac{\log n}{B\log
B}</span> Where B is a bound for small factors, n is the order. (r-s) is
… and q is the remainder of incomplete factorization</p>
<h3 id="z_p-field"><span class="math inline">\Z_p</span> Field</h3>
<p><strong>Field</strong> is a ring where every possible element that is
not 0, is invertible.</p>
<p>Example fields: rational, real, complex numbers. We will use <span
class="math inline">Z_p</span> for p prime</p>
<p><strong>Theorem</strong> - <span class="math inline">\Z_p</span>
structure</p>
<ol type="1">
<li><span class="math inline">Z_p^* = \{1, ..., p-1\}</span> (GCD = 1,
therefore they are invertable)</li>
<li>(Little Fermat Theorem) for any <span class="math inline">x \in
Z_p^*</span> we have <span class="math inline">x^{p-1} = 1 (mod\
p)</span> (Lagrange theorem)</li>
<li><span class="math inline">Z_p^*</span> is a cyclic group. So there
exist g such that: <span class="math inline">Z_p^* = \{g^0, g^1, g^2\
mod\ p, .., g^{p-2}\ mod\ p\}</span></li>
</ol>
<p>subgroup of <span class="math inline">\langle g \rangle \subseteq
Z_p^*</span> of prime order q (if not, then it would be just even
numbers): <span class="math inline">\langle g \rangle = \{1, g, ..,
g^{q-1} \} \lrarr \{0, 1, ..., q-1\} \subseteq Z_p^*</span></p>
<p>Example: SSH2 parameters</p>
<h4 id="the-discrete-logarithm-problem">The discrete logarithm
problem</h4>
<p><strong>Definition</strong>: The DL problem, relative to Setup, is
hard if for any (probabilistic polynomial-time) algrorithm A, the
probability that the follong game returns 1 is negl(<span
class="math inline">\lambda</span>):</p>
<pre class="name"><code>DL(λ):
1: Setup(1^λ ) → (group, q, g)
2: pick x ∈ Zq
3: X ← g^x
4: A(group, q, g, X) → x&#39;
5: return 1_X=g^x′</code></pre>
<p>Negligible function - the output is very small - goes to 0 faster
than any inverse of polynomial.</p>
<p>Examples of groups: <span class="math inline">Z_n</span> - dividing
by g is easy because the operations are easy <span
class="math inline">Z_p^*</span> - believed to be hard (not proven),
could be easy if there is extra information over an elliptic curve -
believed to be hard</p>
<p>The notion of game: Game(security parameter): 1: setup of parameters
2: initialization of the game 3: A(what he should know) -&gt; result 4:
return 1 (on winning condition)</p>
<p>Advantage of A: Adv(security parameter) = Pr[Game -&gt; 1]</p>
<p>Security: <span class="math inline">\forall</span>PPT Adv = negl</p>
<p>Some facts about DL Problem:</p>
<ul>
<li>it is easy on quantum computer - Shor algorithm (quasilinear
time)</li>
<li>easy if n has only small prime factors (e.g. 2^100) - Pohlig-Hellman
algorithm -&gt; that is why n is preferred to be prime number</li>
<li>best algorithm for a subgroup <span class="math inline">Z_p^*</span>
with n and p prime:
<ul>
<li>General Number Field Sieve (GNFS) with complexity e^(equiv to const
* log n * log log n) &lt;- smaller than exponential; but if n is large
enough</li>
<li>This is mostly precomputation (without X)</li>
<li>the computation from y (after precomputation) takes similar time but
smaller by a constant in exponent</li>
</ul></li>
<li>Generic algorithms <span class="math inline">O(\sqrt{n})</span>
<ul>
<li>baby-step giant-step algorithm</li>
<li>Pollard p algorithm</li>
</ul></li>
</ul>
<h4 id="baby-step-giant-step-algorithm">Baby-step giant-step
algorithm</h4>
<p>Be given some x and know which power of g it is. Take a giant step -
size of l = <span class="math inline">\lceil \sqrt{B} \rceil</span> for
l steps insert (g^il, i) into hashtable</p>
<p>for l steps compute z = Xg^-j if we have a (z,i) in the hash table
then yielf x = il +j and stop</p>
<p>This means that this algorithm is O(l) = <span
class="math inline">O(\sqrt{B})</span></p>
<p>Pollar p algorithm is also in similar complexity.</p>
<h4 id="attacks-based-on-precomputation">Attacks based on
precomputation</h4>
<p>for example for p length of 512 bits precomputation (on 1 core) will
take 10.2 years, and attack (on 1 core) will take 10 minutes. whereas
1024 bits, precomputation 45 million years, and attack 30 days.</p>
<p>SSH2 uses a fixed p of 1024 bits.</p>
<h3 id="diffie-hellman-key-agreement-protocol">Diffie-Hellman key
agreement protocol</h3>
<p>Both compute K=g^xy.</p>
<p>Adversary knows the group, g, and all messages exchanged - X, Y (g^x,
g^y). Computational Diffie-Hellman Problem.</p>
<h4 id="unavoidable-active-attack">Unavoidable active attack</h4>
<p>MITM attack: Eve replaces the communication with their key and runs
Diffie-Hellman with Alice, Bob and they will not know that they are
talking to Eve.</p>
<p>It is not avoidable, but all other attacks, where adversary is
passive should be avoided.</p>
<p>Diffie-Hellman shall resist to passive attack, so must be
computationally hard.</p>
<h4 id="computational-diffie-hellman-problem">Computational
Diffie-Hellman problem</h4>
<p>CDH(λ): 1: Setup(1^λ) → (group, q, g) 2: pick x, y ∈ Zq 3: X ← g^x ,
Y ← g^y 4: A(group, q, g, X , Y ) → K 5: return 1 if K=g^xy</p>
<p>The goal of this game is to find K where K = g^xy</p>
<p>hardness of this problem requires the Discrete Logarithm Problem to
be hard Examples: subgroup of <span class="math inline">Z_p^*</span> of
prime order q elliptic curve</p>
<h4 id="cdh-hard-implies-dl-hard">CDH hard <span
class="math inline">\implies</span> DL hard</h4>
<ul>
<li>assume CDH is hard</li>
<li>to prove DL hardness, consider DL algorithm A</li>
<li>construct B, s.t. A wins DL <span
class="math inline">\implies</span> B wins CDH: Pr[DL -&gt; 1] <span
class="math inline">\le</span> Pr[Modified CDH -&gt; 1] = negl</li>
<li><span class="math inline">X = g^{x&#39;} \implies K = Y^{x&#39;} =
g^{yx&#39;} = X^y = g^{xy}</span></li>
</ul>
<h4 id="decisional-diffie-hellman-problem">Decisional Diffie-Hellman
problem</h4>
<p>there is an extra input to the game - bit b.</p>
<p>if the bit is 1, z is xy, otherwise z is totally random number. The
game is for the adversary to find out when the bit is 0 or 1, which
means that the goal is for them to not distinguish from these cases:</p>
<p>Adv(<span class="math inline">\lambda</span>) = Pr[DDH(<span
class="math inline">\lambda</span>, 1) -&gt; 1] - Pr[DDH(<span
class="math inline">\lambda</span>, 0) -&gt; 1] = negl(<span
class="math inline">\lambda</span>)</p>
<h4 id="ddh-hard-implies-cdh-hard">DDH hard <span
class="math inline">\implies</span> CDH hard</h4>
<p>assume DDH is hard consider C(group,q,g,X,Y,Z): pick x’ in <span
class="math inline">Z_q</span> return 1 if X=g^x’, Z=Y^x’</p>
<p>negl = Adv C = Pr[DDHC (1) → 1]−Pr[DDHC (0) → 1] = 1/q - 1/q^2 ~
1/q</p>
<p>hence 1/q = negl</p>
<p>transition from CDH game to DDH game. transformation: B(group,
q,g,X,Y,Z): run A(group,g,X,Y) -&gt; K return 1 if K=Z</p>
<p>DDH in B (1) -&gt; 1 is equivalent to CDH in A -&gt; 1</p>
<p>Pr[DDH in B (1) → 1] = Pr[CDH in A → 1]</p>
<p>Pr[DDH in B (0) → 1] = 1/q = negl</p>
<p>hence Adv B (<span class="math inline">\lambda</span>) = Adv A (<span
class="math inline">\lambda</span>) - negl we know that Adv B (λ) =
negl(λ) (since DDH is hard) hence Pr[A wins] = negl(λ)</p>
<h4 id="ddh-easy-case-of-a-group-whose-order-has-a-smooth-factor">DDH
easy case of a group whose order has a smooth factor</h4>
<p>That is why we need prime factors.</p>
<h3 id="exercises-3">Exercises 3</h3>
<h4 id="exercise-1">Exercise 1</h4>
<p>Latin square of order 4 l: 1234 2341 3412 4123 p = 3, k = 2 c(p) =
l_kx = 4</p>
<p>Perfect secrecy proof: for all x, y, where Pr[Y=y] <span
class="math inline">\ne</span> 0, Pr[X=x | Y=y] = Pr[X=x] If the key is
uniformly distributed, there is no chance to guess the relation between
the text and the cipher text because key picks the matrix entry.</p>
<p>Proper proof: let X be the random var for the plaintext, Y be the
random var for the ciphertext and K for the key.</p>
<p>Then we have: <span class="math display">Pr[X = x, Y = y] =
\sum_{k=1}^{n} Pr[X = x, Y = y | K =k]Pr[K=k] =
\frac{1}{n}\sum_{k=1}^{n} Pr[X = x, Y = y | K =k]</span> since the key
is uniformly distributed. Moreover <span class="math display">Pr[X = x,
Y = y | K =k] = 1_{l_{x,k=y}}Pr[X=x | K=k]</span> as for a given message
x and key k there is only one corresponding y. Finally, since X and K
are independent, <span class="math display">Pr[X=x, Y=y] =
\frac{1}{n}\sum_{k=1}^{n} 1_{l_{x,k=y}}Pr[X=x] =
\frac{Pr[X=x]}{n}</span> because as L is a latin square, there is only
one value k such that y. On the other hand: <span
class="math display">Pr[Y=y] = \sum_{x=1}^{n}Pr[Y=y, X=x] =
\frac{1}{n}</span></p>
<p>We conclude that Pr[X=x | Y=y] = Pr[X=x].</p>
<h4 id="exercise-2">Exercise 2</h4>
<ol type="1">
<li><p>Why is it insecure: the distribution is not uniform because the
likelyhood of k mod 12 being 2 is 1/12 and k mod 12 being 7 is
1/6</p></li>
<li><p>y = (k+x) mod 4, x in {0,1} if k mod n is not uniformly
distributed, then it is not secure. Because k is uniformly distributed
modulo 6, the scheme is secure for factors of 6 = {1, 2, 3, 6}. The
scheme is not secure for mod 12. For mod 4:</p></li>
</ol>
<p>k1 mod 4 and k2 mod 4 have a distribution for i={0,3} = 1/6, for i=
{1,2} = 1/3, so for i = 0 it’s 1/4, for i=1 it’s 2/9 … so the
distribution is not uniform for n=4</p>
<h4 id="exercise-3">Exercise 3</h4>
<p>G is multiplicative group. <span class="math inline">S \subseteq
G</span> and S <span class="math inline">\ne</span> 0, such that for all
<span class="math inline">a, b \in S</span>, we have <span
class="math inline">ab^{-1} \in S</span>. Show that S is a group.</p>
<p>Properties:</p>
<ol type="1">
<li>neutral element: for <span class="math inline">a \in S</span>, we
have <span class="math inline">aa^{-1} = e \in S</span>, which means
that neutral element e is in S</li>
<li>invertability: we have that <span class="math inline">e \in
S</span>. Then, for any <span class="math inline">a \in S</span>, we
have <span class="math inline">ea^{-1} \in S</span>, thus <span
class="math inline">a^{-1} \in S</span></li>
<li>closure: for any <span class="math inline">a,b \in S</span>, we have
<span class="math inline">b^{-1} \in S</span>, thus <span
class="math inline">a(b^{-1})^{-1} = ab \in S</span></li>
<li>associativity: it is inherited from G</li>
</ol>
<p>Thus S is a group.</p>
<h4 id="exercise-4">Exercise 4</h4>
<p>For all i,j in {1,2,3,4,5,6}, i <span class="math inline">\ne</span>
j we have yi <span class="math inline">\ne</span> yj. (intuition - all
are different) total combinations = 6^12 allowed events in x: assume
each pair has two digits, so 36 possibilities.</p>
<p>Pr[events] = 36 * 35 * 34 * 33 * 32 * 31 / 6^12</p>
<p>There exists i,j in {1,2,3,4,5,6}, i <span
class="math inline">\ne</span> j we have yi <span
class="math inline">\ne</span> yj. (intuition - there exists a pair that
is different)</p>
<p>1 - 6^2 / 6^12 = 1 - 6^-10</p>
<h4 id="hardness-depending-on-groups">Hardness depending on groups</h4>
<p>DL hard (easy if order is smooth) <span
class="math inline">\lArr</span> CDH hard <span
class="math inline">\lArr</span> DDH hard (easy if order has any
smooth/small factor &gt;1)</p>
<h4 id="problems-when-not-checking-group-membership">Problems when not
checking group membership</h4>
<p>Assume: Bob uses a static key Y Bob’s algorithm run even though X
does not belong to the group. we can select X outside of the group, with
small order q’.</p>
<p>Say Alice is malicious, it takes X of small order q’, Bob creates the
key K = X^y, when y is static</p>
<p>Alice then can do an exhaustive search on y_q’ because if X is of
small factor, it can do an operation modulo factor of X</p>
<h3 id="unavoidable-active-attack---mitm">Unavoidable Active Attack -
MITM</h3>
<p>Eve stays in the middle during the entire communication between alice
and bob.</p>
<h4 id="mitm-attack-making-k1-k2---i">MITM attack making K1 = K2 -
i</h4>
<p>Eve uses it’s generator as 1 - makes Alice’s and Bob’s keys known to
them, but easy to avoid - check if not 1</p>
<h4 id="mitm-attack-making-k1-k2---ii">MITM attack making K1 = K2 -
ii</h4>
<p>Using groups of order divisible by w such that DL is easy in <span
class="math inline">\langle g^w\rangle</span></p>
<p>Eve creates X’ = X^w Eve creates Y’ = Y^w solves X’ =
g<sup>x’w</sup>, K = Y<sup>x’w</sup> K = g<sup>xyw</sup></p>
<p>Y<sup>x’w</sup> = g<sup>xyw</sup> = ..</p>
<p>Avoided - if the group is of prime order</p>
<h4 id="problems-with-subgroups">Problems with Subgroups</h4>
<p>we can compute log X modulo the small factors of the order</p>
<p>…</p>
<h4 id="other-issues-weird-key-distribution">Other issues: Weird key
distribution</h4>
<p>the final key K is random in <span class="math inline">\langle g
\rangle</span> which has its own representation We need a bitstring with
a reliable distribution solution - use Key derivation function (KDF)</p>
<h4 id="summary---problems-with-the-original-dh-protocol">Summary -
problems with the original DH protocol</h4>
<p>nobody is checking the group membership X and Y problems with
subgroups of <span class="math inline">\langle g \rangle</span> subgroup
{1} (unavoidable) other subgroups of <span class="math inline">\langle g
\rangle</span></p>
<p>problem with g^xy having a bad distribution</p>
<h4 id="hard-cases">Hard cases</h4>
<p>the DDH problem is believed to be hard relative to:</p>
<ul>
<li>large subgroup of prime order of <span
class="math inline">Z_p^*</span> (p prime)
<ol type="1">
<li>pick a random prime q of size 2<span
class="math inline">\lambda</span></li>
<li>pick a random p of size f(<span class="math inline">\lambda</span>)
such that q|p-1</li>
<li>start again until p is prime</li>
<li>pick a random g in <span class="math inline">Z_p^*</span> of order
q</li>
</ol></li>
<li>large supgroup of prime order of a “regular” elliptic curve</li>
</ul>
<h3 id="correct-dh-key-exchange">Correct DH key exchange</h3>
<p>Assume group <span class="math inline">\langle g \rangle</span>
generated by some g of prime order q</p>
<p>Alice picks <span class="math inline">x \in Z_q^*</span> Bob checks
if <span class="math inline">X \notin \langle g \rangle - {1}</span>, if
so, abort Bob creates <span class="math inline">y \in Z_q^*</span>, and
K = KDF(X^y) Alice checks if <span class="math inline">Y \notin \langle
g \rangle - {1}</span>, if so, abort Alice sets K = KDF(Y^x)</p>
<h3 id="standard-rfc-2631">Standard RFC 2631</h3>
<h4 id="group-parameter-generation-in-rfc-2631">Group parameter
generation in RFC 2631</h4>
<figure>
<img src="Images/Screenshot%20from%202023-10-11%2008-52-35.png"
alt="Algorithm" />
<figcaption aria-hidden="true">Algorithm</figcaption>
</figure>
<p>Line 5 is such that we get large odd number</p>
<p>Line 13 is such that we get an odd number</p>
<h4 id="parameter-validation-in-rfc-2631">Parameter Validation in RFC
2631</h4>
<p>Group parameters validation:</p>
<ul>
<li>p and q are prime and q divides p-1</li>
<li>g^q mod p = 1 and 1 &lt; g &lt; p</li>
</ul>
<p>Public key validation: check 2 <span class="math inline">\le</span> y
<span class="math inline">\le</span> p -1 and y^p mod p = 1</p>
<h4 id="ssh2-example">SSH2 example</h4>
<p>It uses g = 2 generator, which is convenient</p>
<p>It executes the Diffie-Hellman key exchange, with server creates a
hash for Ks (DSA using p,q,g signature), and client computing hash to
verify the signature from the server.</p>
<p>The MITM is removed because they can only alter Ks, which would be
detected when verifying the signature</p>
<h3 id="elgamal-public-key-cryptosystem">ElGamal Public key
cryptosystem</h3>
<h4 id="non-deterministic-encryption">Non-deterministic Encryption</h4>
<p>The cipher text is a larger space than plaintext -&gt; encryption
could be probabilistic, decryption has to be deterministic</p>
<h4 id="semi-static-dh-pubkey-encryption">Semi-static-DH Pubkey
encryption</h4>
<p>Alice has Bob’s pubkey, picks x random Bob’s key K=KDF(<span
class="math inline">x^y</span>)</p>
<h4 id="plain-elgamal-encryption-case">Plain ElGamal Encryption
case</h4>
<p>in the original: it was in <span class="math inline">Z_p^*</span>, so
not prime order no KDF and symEnc was one time pad</p>
<h4 id="elgamal-cryptosystem">ElGamal cryptosystem</h4>
<p>Public parameter: (g, n), a group <span class="math inline">\langle g
\rangle</span> of order n generated by some g</p>
<p>Set up: generate a random x in <span class="math inline">Z_n</span>,
and compute y = <span class="math inline">g^x</span></p>
<p>Message: an element m in <span class="math inline">\langle g
\rangle</span></p>
<p>Public key: pk = y</p>
<p>Secret key: sk = x</p>
<p>Encryption: random r in <span class="math inline">Z_n</span>, compute
u = <span class="math inline">g^r</span>, and vernam cipher v = <span
class="math inline">my^r</span>. Cipher text is (u,v)</p>
<p>Decrypt: extract the u and v parts of the ciphertext and compute m =
<span class="math inline">vu^{−x}</span></p>
<h4 id="complexity">Complexity</h4>
<p>Domain parameters: Typically O(<span class="math inline">l^4</span>)
- the complexity of generating a prime number Generator - O(<span
class="math inline">l^3</span>) - complexity of multiplication l^2, and
power is complexity of the size of the power. Encryption - O(<span
class="math inline">l^3</span>) Decryption - O(<span
class="math inline">l^3</span>)</p>
<h4 id="related-problems">Related problems</h4>
<h5 id="egkr-elgamal-key-recovery-problem">EGKR (ElGamal Key Recovery
Problem)</h5>
<p>recovering secret key</p>
<p>game where we set up the group, pubkey, and give them to adversary to
get the secret</p>
<h5 id="egd-elgamal-decryption-problem">EGD (ElGamal Decryption
Problem)</h5>
<p>game where we set up the group, pubkey, plaintext, we encrypt it, and
the goal is to retrieve the plaintext</p>
<p>we can show that key recovery problem to DL problem (just change of
notation) and that decryption problem to CDH problem</p>
<h4 id="egd-hard-rarr-cdh-hard">EGD hard <span
class="math inline">\rArr</span> CDH hard</h4>
<p>assume EGD is hard to prove CDH hardnes, consider a CDH algorithm A
construct B s.t. A wins CDH <span class="math inline">\rArr</span> B
wins EGD:</p>
<p>if A succeeds computing the K, they obtain the correct plaintext.
Therefore, CDH is hard</p>
<h4 id="cdh-hard-rarr-egd-hard">CDH hard <span
class="math inline">\rArr</span> EGD hard</h4>
<p>assume CDH hard to prove EGD hardness, consider EGD algorithm A
construct B s.t. A wins EGD <span class="math inline">\rArr</span> B
wins CDH</p>
<p>we pick random v in B and then when the m is obtained in EDH, CDH is
also solved.</p>
<h5 id="elgamal-encryption-security">ElGamal Encryption Security</h5>
<p>key recovery is equivalent to solving DL decryption is equivalent to
the solving CDH INDCPA security is equivalent solving DDH</p>
<p>how to map a bitstring to a group element, because we only know how
to encrypt that</p>
<h2 id="rsa-cryptography">RSA Cryptography</h2>
<h3 id="euler-totient-function">Euler Totient Function</h3>
<p><span class="math inline">\phi(n)</span> is the order of <span
class="math inline">Z_n^*</span></p>
<p>Theorem: given an integer n, we have the following results:</p>
<ul>
<li>for all <span class="math inline">x \in Z_n</span> we have <span
class="math inline">x \in Z_n^* \lrArr gcd(x,n) = 1</span></li>
<li>Zn is a field iff n is prime</li>
<li>for all <span class="math inline">x \in Z_n</span> we have <span
class="math inline">x^{\phi(n)} \equiv 1 (mod n)</span> (langrange
theorem)</li>
<li>if e is such that gcd(e, <span class="math inline">\phi(n)</span>) =
1, we let d = e^-1 mod <span class="math inline">\phi(n)</span>. For all
<span class="math inline">y \in Z_n^*</span>, <span
class="math inline">y^d</span> mod n is the only eth root of y modulo
n.</li>
</ul>
</body>
</html>
