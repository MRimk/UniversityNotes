<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Embedded System Design</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="css/pandoc.css" />
  <style>
    html {
      font-size: 100%;
      overflow-y: scroll;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }

    body {
      color: #444;
      font-family: Georgia, Palatino, "Palatino Linotype", Times,
        "Times New Roman", serif;
      font-size: 12px;
      line-height: 1.7;
      padding: 1em;
      margin: auto;
      max-width: 42em;
      background: #fefefe;
    }

    a {
      color: #0645ad;
      text-decoration: none;
    }

    a:visited {
      color: #0b0080;
    }

    a:hover {
      color: #06e;
    }

    a:active {
      color: #faa700;
    }

    a:focus {
      outline: thin dotted;
    }

    *::-moz-selection {
      background: rgba(255, 255, 0, 0.3);
      color: #000;
    }

    *::selection {
      background: rgba(255, 255, 0, 0.3);
      color: #000;
    }

    a::-moz-selection {
      background: rgba(255, 255, 0, 0.3);
      color: #0645ad;
    }

    a::selection {
      background: rgba(255, 255, 0, 0.3);
      color: #0645ad;
    }

    p {
      margin: 1em 0;
    }

    img {
      max-width: 100%;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      color: #111;
      line-height: 125%;
      margin-top: 2em;
      font-weight: normal;
    }

    h4,
    h5,
    h6 {
      font-weight: bold;
    }

    h1 {
      font-size: 2.5em;
    }

    h2 {
      font-size: 2em;
    }

    h3 {
      font-size: 1.5em;
    }

    h4 {
      font-size: 1.2em;
    }

    h5 {
      font-size: 1em;
    }

    h6 {
      font-size: 0.9em;
    }

    blockquote {
      color: #666666;
      margin: 0;
      padding-left: 3em;
      border-left: 0.5em #eee solid;
    }

    hr {
      display: block;
      height: 2px;
      border: 0;
      border-top: 1px solid #aaa;
      border-bottom: 1px solid #eee;
      margin: 1em 0;
      padding: 0;
    }

    pre,
    code,
    kbd,
    samp {
      color: #000;
      font-family: monospace, monospace;
      _font-family: "courier new", monospace;
      font-size: 0.98em;
    }

    pre {
      white-space: pre;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    b,
    strong {
      font-weight: bold;
    }

    dfn {
      font-style: italic;
    }

    ins {
      background: #ff9;
      color: #000;
      text-decoration: none;
    }

    mark {
      background: #ff0;
      color: #000;
      font-style: italic;
      font-weight: bold;
    }

    sub,
    sup {
      font-size: 75%;
      line-height: 0;
      position: relative;
      vertical-align: baseline;
    }

    sup {
      top: -0.5em;
    }

    sub {
      bottom: -0.25em;
    }

    ul,
    ol {
      margin: 1em 0;
      padding: 0 0 0 2em;
    }

    li p:last-child {
      margin-bottom: 0;
    }

    ul ul,
    ol ol {
      margin: 0.3em 0;
    }

    dl {
      margin-bottom: 1em;
    }

    dt {
      font-weight: bold;
      margin-bottom: 0.8em;
    }

    dd {
      margin: 0 0 0.8em 2em;
    }

    dd:last-child {
      margin-bottom: 0;
    }

    img {
      border: 0;
      -ms-interpolation-mode: bicubic;
      vertical-align: middle;
    }

    figure {
      display: block;
      text-align: center;
      margin: 1em 0;
    }

    figure img {
      border: none;
      margin: 0 auto;
    }

    figcaption {
      font-size: 0.8em;
      font-style: italic;
      margin: 0 0 0.8em;
    }

    table {
      margin-bottom: 2em;
      border-bottom: 1px solid #ddd;
      border-right: 1px solid #ddd;
      border-spacing: 0;
      border-collapse: collapse;
    }

    table th {
      padding: 0.2em 1em;
      background-color: #eee;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
    }

    table td {
      padding: 0.2em 1em;
      border-top: 1px solid #ddd;
      border-left: 1px solid #ddd;
      vertical-align: top;
    }

    .author {
      font-size: 1.2em;
      text-align: center;
    }

    @media only screen and (min-width: 480px) {
      body {
        font-size: 14px;
      }
    }
    @media only screen and (min-width: 768px) {
      body {
        font-size: 16px;
      }
    }
    @media print {
      * {
        background: transparent !important;
        color: black !important;
        filter: none !important;
        -ms-filter: none !important;
      }

      body {
        font-size: 12pt;
        max-width: 100%;
      }

      a,
      a:visited {
        text-decoration: underline;
      }

      hr {
        height: 1px;
        border: 0;
        border-bottom: 1px solid black;
      }

      a[href]:after {
        content: " (" attr(href) ")";
      }

      abbr[title]:after {
        content: " (" attr(title) ")";
      }

      .ir a:after,
      a[href^="javascript:"]:after,
      a[href^="#"]:after {
        content: "";
      }

      pre,
      blockquote {
        border: 1px solid #999;
        padding-right: 1em;
        page-break-inside: avoid;
      }

      tr,
      img {
        page-break-inside: avoid;
      }

      img {
        max-width: 100% !important;
      }

      @page :left {
        margin: 15mm 20mm 15mm 10mm;
      }

      @page :right {
        margin: 15mm 10mm 15mm 20mm;
      }

      p,
      h2,
      h3 {
        orphans: 3;
        widows: 3;
      }

      h2,
      h3 {
        page-break-after: avoid;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/darkreader@4.7.15/darkreader.min.js"></script>
  <script>
    DarkReader.enable({
      brightness: 100,
      contrast: 90,
      sepia: 10,
    });
  </script>
  <link
    rel="icon"
    type="image/png"
    href="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcTJg97A-Sa8mxjkRCmjR51WjHATLvq2aF89Z1CprR2WcQ60qYZC"
  />
  <meta name="theme-color" content="#252525" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Embedded System Design</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#embedded-system" id="toc-embedded-system">Embedded
System</a>
<ul>
<li><a href="#how-to-design-the-system"
id="toc-how-to-design-the-system">How to design the system</a></li>
<li><a href="#virtual-prototype" id="toc-virtual-prototype">Virtual
prototype</a></li>
<li><a href="#embedded-system-components"
id="toc-embedded-system-components">Embedded system components</a></li>
<li><a href="#hwsw-partitioning" id="toc-hwsw-partitioning">HW/SW
partitioning</a></li>
<li><a href="#memories" id="toc-memories">Memories</a></li>
<li><a href="#how-to-use-these-memories"
id="toc-how-to-use-these-memories">How to use these memories?</a></li>
<li><a href="#testbenching" id="toc-testbenching">Testbenching</a></li>
</ul></li>
<li><a href="#custom-instructions" id="toc-custom-instructions">Custom
instructions</a>
<ul>
<li><a href="#alu" id="toc-alu">ALU</a></li>
<li><a href="#custom-instruction-hw-interface"
id="toc-custom-instruction-hw-interface">Custom instruction hw
interface</a></li>
<li><a href="#custom-instruction-sw-interface"
id="toc-custom-instruction-sw-interface">Custom instruction SW
interface</a></li>
<li><a href="#profiling" id="toc-profiling">Profiling</a></li>
</ul></li>
<li><a href="#timing-closure" id="toc-timing-closure">Timing closure</a>
<ul>
<li><a href="#rtl-register-transfer-level-design"
id="toc-rtl-register-transfer-level-design">RTL (Register Transfer
Level) design</a></li>
<li><a href="#what-is-timing-closure"
id="toc-what-is-timing-closure">What is timing closure</a></li>
</ul></li>
<li><a href="#bus-architectures" id="toc-bus-architectures">Bus
architectures</a>
<ul>
<li><a href="#simple-bus-architectures"
id="toc-simple-bus-architectures">Simple bus architectures</a></li>
<li><a href="#crossbar-architectures"
id="toc-crossbar-architectures">Crossbar architectures</a></li>
</ul></li>
</ul>
</nav>
<!-- markdownlint-disable MD010 MD041 MD001 MD036 MD029 MD034-->
<h2 id="embedded-system">Embedded System</h2>
<p>There is no exact definition, but the embedded system is a type of
computer designed to solve a specific problem or task.</p>
<p>It typically use a microprocessor combined with other hw and sw to
solve a specific computing problem. Microprocessor range from simple
8-big verision to 64-bit or multi-cores.</p>
<p>Embedded system software ranges from a small executive to a large
real-time operating system with a GUI.</p>
<p>Typically, the embedded system software must respond to events and
must not crash.</p>
<h3 id="how-to-design-the-system">How to design the system</h3>
<p>Waterfall model:</p>
<ol type="1">
<li>System specification</li>
<li>ASIC design (black boxes drawings)</li>
<li>HW prototype design</li>
<li>Firmware design</li>
<li>Software design</li>
<li>System integration and test</li>
<li>Industrialisation (optimize for production)</li>
<li>Support and maintain the product in the market</li>
</ol>
<p>This takes way too long. Nowadays time to market is very
important.</p>
<p>Therefore now a different method is used: Hardware/Software
co-design:</p>
<ol type="1">
<li>System specification</li>
<li>Architecture exploration and Hw/Sw parititioning using virtual
prototyping</li>
<li>In parallel:<br />
ASIC design -&gt; hardware prototype design<br />
Firmware design -&gt; Software design</li>
<li>System integration and test</li>
<li>Industrialisation (optimize for production)</li>
<li>Support and maintain the product in the market</li>
</ol>
<h3 id="virtual-prototype">Virtual prototype</h3>
<p>A system that emulates the complete system on a functional level (not
necessarily cycle-true).</p>
<p>VP is based on the OpenRISC micro-controller. Is completely written
Verilog and is running on the GECKO4Education EPFL-Edition.</p>
<h3 id="embedded-system-components">Embedded system components</h3>
<p>The VP has similar components to the usual systems.</p>
<p>It has:</p>
<ul>
<li>RS232 UART which is used to debug and control the system.</li>
<li>Simple 32-bit based bus architecture, to which it is easy to attach
own systems (e.g. DMA controller)</li>
<li>VGA text and GUI controller (720p)</li>
<li>SPI-flash interface wher you can store the program</li>
<li>OpenRISC CPU, which has instruction cache and 4kByte Scratch pad
memory</li>
</ul>
<h3 id="hwsw-partitioning">HW/SW partitioning</h3>
<p>For now it is usual to take one microcontroller (usually an overkill)
and then put as much software as it requires. The problem is when it is
put under a battery power.</p>
<p>Standard hardware is not sufficient, so application-specific hw is
necessary. To have this, hardware/software partitioning is used, and
trade-offs are adhered to.</p>
<p>There is no one way to partition the system.</p>
<h4 id="the-tradeoffs">The tradeoffs</h4>
<p>Performance, Area, Energy, and the biggest - Time-to-market</p>
<p>The most expensive is the engineer.</p>
<h4 id="how-to-do-it---example">How to do it - example</h4>
<p>Take a camera module. It provides data in RGB565 (because we are most
sensitive to green). It gives an image of 640x480 pixels. It produces 15
images each second.</p>
<p>Storage inside the chip is very expensive, thus we transfer the date
using DMA-master to SDRAM controller.</p>
<p>We also have VGA controller that has HDMI connector of 60 images each
second. DMA-master transfers the information from SDRAM controller.</p>
<p>We want to have edge detection on the live stream.</p>
<p>It is done on the OpenRISC processor. Make the grayscale and then
with the Sobel algorithm we get the edges.</p>
<p>How does edge detection work: if there is a big difference between
two columns (or rows) of the pixels, and if the contrast is above the
threshold, then there is an edge. This is Sobel algorithm.</p>
<p>For vertical edges there is a matrix filter (note that it shrinks the
image by an removing outer pixels):</p>
<p><span class="math display">
\begin{matrix}
-1 &amp; 0 &amp; 1 \\
-2 &amp; 0 &amp; 2 \\
-1 &amp; 0 &amp; 1
\end{matrix}
</span></p>
<p>And for horizontal edges there is this filter:</p>
<p><span class="math display">
\begin{matrix}
-1 &amp; -2 &amp; -1 \\
0 &amp; 0 &amp; 0 \\
-1 &amp; -2 &amp; -1
\end{matrix}
</span></p>
<p>And then the pixels with edges are estimated <span
class="math inline">\sqrt{dX^^2 + dY^^2}</span> with <span
class="math inline">|dX| + |dY|</span>. And then put this estimation on
the threshold, which either gives a 1 or 0 (draws the pixel or does
not).</p>
<p>This is an inefficient way of doing this algorithm, because you need
to read the image twice (transfer the image over the bus twice).</p>
<p>To optimize this algorithm: we take the 9 pixels, compute dX, dY in
registers, compute the threshold, and save the pixel. Thus it saves the
work for DRAM and the bus.</p>
<p>It is still impossible to do this, because the cpu cycles per pixel
for the Sobel algorithm is 30 cycles, and the available cycles
(calculated for hw), it is only 16 cycles. So it is not real time edge
detection.</p>
<h3 id="memories">Memories</h3>
<p>Accelerating in hardware - custom instructions, accelerators, stream
processing. They often require some memory for temporal storage.</p>
<h4 id="synchronous-static-random-access-memories-ssrams">Synchronous
Static Random Access Memories (SSRAMs)</h4>
<p>SSRAMs are the only mmeory found in digital technology nodes.</p>
<p>These memories on-chip usually have unidirectional data-buses, hence
<code>dataIn</code> and <code>dataOut</code>. Because if we have any
directional bus, we need capacitors to store buffers, thus it becomes
slow. The signal <code>address</code> selects the memory cell and the
signal <code>writeEnable</code> indicates if the cell should be
written.</p>
<p>There are two behaviours in case of a write (since they are
synchronous):</p>
<ul>
<li><strong>write before read</strong> - the value written to the memory
cell is also available on the output. Flip flop is in the address
lines.</li>
<li><strong>read before write</strong> - the value in the memory cell
prior the write operation is available on the output. Flip flop is after
the multiplexer.</li>
</ul>
<p>Address and dataIn is stored in the flipflop at the posedge of the
clock and then at the next posedge it write the data into the memory
cell. Memories are completely synchronous, therefore we can use them as
flipflops, which is good.</p>
<p>For the read, due to the synchronous behaviour, we have a delay of 1
clock cycle from when the address is put into the flipflop. This
decalation of clock cycle has to be accounted.</p>
<p>SSRAMs can be found in different configs:</p>
<ul>
<li>single-ported (one address in, one data in, one data out) - this is
the smallest memory, but arguably, most used.</li>
<li>semi-dual-ported (A address with data in and data out, and B address
with only data out) - two read-ports but only one can write</li>
<li>true-dual-ported (A and B port can write and read), two complete
ports that access the same memory array, but can have different clocks.
This can result in undefined behaviour if the write on both busses to
the same location is not prevented. Solution - block A port on the
rising edge, block B port on the falling edge</li>
</ul>
<h5 id="verilog-single-ported-ssram">Verilog single-ported SSRAM</h5>
<p>SSRAM has parameters - bitwidth (how many bits data in and out have),
nrOfEntries (how many entries can be stored in the memory),
readAfterWrite (parametrization for later reuse)</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> singlePortSSRAM #<span class="op">(</span> <span class="dt">parameter</span> bitwidth <span class="op">=</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">parameter</span> nrOfEntries <span class="op">=</span> <span class="dv">512</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">parameter</span> readAfterWrite <span class="op">=</span> <span class="dv">0</span> <span class="op">)</span></span></code></pre></div>
<p>Input is clock, writeEnable (bit), address (size is log2 of number of
entries), dataIn and dataOut (size of bitwidth)</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dt">input</span> <span class="dt">wire</span> clock<span class="op">,</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>            writeEnable<span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">input</span> <span class="dt">wire</span> <span class="op">[</span><span class="dt">$clog2</span><span class="op">(</span>nrOfEntries<span class="op">)-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> address<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">input</span> <span class="dt">wire</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> dataIn<span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">output</span> <span class="dt">reg</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> dataOut<span class="op">);</span></span></code></pre></div>
<p>memoryContent is a 2D array of entries of size bitwidth</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">reg</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> memoryContent <span class="op">[</span>nrOfEntries<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">];</span></span></code></pre></div>
<p>It works as a flipflop but is conditional on the write:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clock<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">begin</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="op">(</span>readAfterWrite <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> dataOut <span class="op">&lt;=</span> memoryContent<span class="op">[</span>address<span class="op">];</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="op">(</span>writeEnable <span class="op">==</span> 1’b1<span class="op">)</span> memoryContent<span class="op">[</span>address<span class="op">]</span> <span class="op">&lt;=</span> dataIn<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="op">(</span>readAfterWrite <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> dataOut <span class="op">&lt;=</span> memoryContent<span class="op">[</span>address<span class="op">];</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<h5 id="verilog-semi-dual-ported">Verilog semi-dual-ported</h5>
<p>It only adds a new address and new dataOut:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="dt">input</span> <span class="dt">wire</span> clock<span class="op">,</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>            writeEnable<span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dt">input</span> <span class="dt">wire</span> <span class="op">[</span><span class="dt">$clog2</span><span class="op">(</span>nrOfEntries<span class="op">)-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> addressA<span class="op">,</span> addressB</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">input</span> <span class="dt">wire</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> dataIn<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">output</span> <span class="dt">reg</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> dataOutA<span class="op">,</span> dataOutB<span class="op">);</span></span></code></pre></div>
<p>And it has a new clock:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clockB<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   dataOutB <span class="op">=</span> memoryContent<span class="op">[</span>addressB<span class="op">];</span></span></code></pre></div>
<h5 id="verilog-true-dual-ported">Verilog true-dual-ported</h5>
<p>It only adds a new address and new dataOut, new writeEnable and new
dataIn:</p>
<p>And it has a new clock:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clockB<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">begin</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="op">(</span>readAfterWrite <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> dataOutB <span class="op">=</span> memoryContent<span class="op">[</span>addressB<span class="op">];</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="op">(</span>writeEnableB <span class="op">==</span> 1’b1<span class="op">)</span> memoryContent<span class="op">[</span>addressB<span class="op">]</span> <span class="op">=</span> dataInB<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="op">(</span>readAfterWrite <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> dataOutB <span class="op">=</span> memoryContent<span class="op">[</span>addressB<span class="op">];</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">end</span></span></code></pre></div>
<h4 id="ssrams-in-asic-and-fpga">SSRAMs in ASIC and FPGA</h4>
<p>In ASIC-design the size of the SSRAms is dependent on the
memory-generator and the <strong>area</strong> you have available. Using
memory is good but it takes up space.</p>
<p>In FPGA-design it is more restricted as the memories are already
implemented. You can only use what you have (for us it is EP4CE30) - 66
SSRAMs available.</p>
<p>Each of this SSRAMs can be used in such configs (all of them are 1KB
in size): 8k x 1bit to 256x32bit or 256x36bit, there could also be 1k x
9bit (where the redundant 1bit is used for error
detection/correction)</p>
<p>Other configs are possible by using partially/multiple of these
SSRAMs</p>
<p>Synthesis tool will map verilog descriptions to these SSRAMs
configs.</p>
<p><strong>However</strong>, if the design uses more SSRAM memory bits
than available on your FPGA, the synthesis tool will implement parts of
the memory bits as flipflops and multiplexers. This will explode the
size of the design (often it cannot be mapped any more on the FPGA) and
have a sever impact on the critical path of the design (<em>read the
speed you can operate your design</em>)</p>
<p>For small memories most FPGAs provide also the LUT-RAMs , which have
most of the a 16x1bit configs.</p>
<h4 id="lut-rams">LUT-RAMs</h4>
<p>LUT-RAMs have the same synchronous write behaviour as SSRAMs but
there is an asynchronous read. This is useful of softcore for the
register file. This is just 16 flipflops.</p>
<p>To get the same behaviour on the synchronous system, you can get
reads on the falling edge of the clock</p>
<h5 id="verilog-lut-rams">Verilog LUT-RAMs</h5>
<div class="sourceCode" id="cb8"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> singlePortLUTRAM #<span class="op">(</span> <span class="dt">parameter</span> bitwidth <span class="op">=</span> <span class="dv">8</span><span class="op">,</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                           <span class="dt">parameter</span> nrOfEntries <span class="op">=</span> <span class="dv">32</span><span class="op">)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">(</span> <span class="dt">input</span> <span class="dt">wire</span> clock<span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                writeEnable<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">input</span> <span class="dt">wire</span> <span class="op">[</span><span class="dt">$clog2</span><span class="op">(</span>nrOfEntries<span class="op">)-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> address<span class="op">,</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">input</span> <span class="dt">wire</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> dataIn<span class="op">,</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">output</span> <span class="dt">wire</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> dataOut<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>   <span class="dt">reg</span> <span class="op">[</span>bitwidth<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">]</span> memoryContent <span class="op">[</span>nrOfEntries<span class="dv">-1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">];</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>   <span class="kw">assign</span> dataOut <span class="op">=</span> memoryContent<span class="op">[</span>address<span class="op">];</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clock<span class="op">)</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>     <span class="kw">if</span> <span class="op">(</span>writeEnable <span class="op">==</span> 1’b1<span class="op">)</span> memoryContent<span class="op">[</span>address<span class="op">]</span> <span class="op">=</span> dataIn<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<h3 id="how-to-use-these-memories">How to use these memories?</h3>
<p>Each of the buffers are used for particular data-accesses in the
system.</p>
<h4 id="ping-pong-buffers">Ping-Pong buffers</h4>
<p>Producer writes its data in one memory whilst the consumer reads form
the other memory. The moment both are done, the memories are
switched.</p>
<p>Applications:</p>
<ul>
<li>data-transfer calculation overlap - calculating when transfering
data (e.g. DMA transfering data when CPU is calculating)</li>
<li>the acces pattern of the producer is different from the consumer.
E.g. in Sobel algorithm, producer gives lines whereas consumer needs
matrices</li>
<li>the push/pop frequency is different hence the producer/consumer have
other timely accesses. E.g. camera only getting pop only when the data
is pushed which is rare.</li>
<li>the consumer needs to access certain data multiple times, whilst the
producer only provides it once.</li>
</ul>
<p>Pro: they are the most versatile kind of buffers</p>
<p>Cons: need to have two SSRAMs and hard to derermine the size of
them?</p>
<p>There is an inferred delay as the consumer always performs the
calculations when already one set of data is provided by the producer.
In the high-frequency environment this could be negligible, but it could
be also important dependant on the application.</p>
<p>What is the influence on <em>area</em>, <em>performance</em>,
<em>power consumption</em> and <em>complexity</em>? (e.g. testing
time)</p>
<p>Everything depends on the requirements and trade-offs.</p>
<h4 id="lifo-buffers">LIFO buffers</h4>
<p>It has an up/down counter that generates the addresses for the SSRAM.
With a push it counts up, and with a pop you count down and that way you
get the information.</p>
<p>Typical applications:</p>
<ul>
<li>data reordering (e.g. camera gives data from left to right, and
screen is drawing right to left)</li>
<li>temporal storage of values (stack or hardware stack)</li>
</ul>
<p>In practice they are not that often used, more preffered are FIFO
buffers.</p>
<h4 id="fifo-buffers">FIFO buffers</h4>
<p>SSRAM is transformed into a circular buffer. This uses binary counter
which can overflow and therefore become circular.</p>
<p>At the beginning the FIFO is empty, so push and pop pointers are
equal.</p>
<p>When the producer pushes, the push pointer is incremented. However,
if the push pointer is equal to pop pointer - 1, the buffer is full,
which makes it lose one slot.</p>
<p>The consumer can pop until the queue is empty.</p>
<p>The consumer and producer has both actions such that state of FIFO
changes continuously</p>
<p>These are the most used buffers.</p>
<p>Applications:</p>
<ul>
<li>timely access pattern buffering</li>
<li>save clock-boundary crossings (one part works at freq x, and another
works at freq y, so use the FIFO buffer to pass the data in
between)</li>
</ul>
<h3 id="testbenching">Testbenching</h3>
<p>Design is Device under test (DUT)</p>
<p>At the input there is input stimuli generator, which provides test
vectors</p>
<p>At the output, the correctness is verified by Output reachtion
checker</p>
<p>The input generator and the output reaction checker form the
test-harnas</p>
<p>The test-harnas is described in a new module, where DUT is used as a
component.</p>
<p>Testbench requires a timescale - simulation for after-synthesis</p>
<p><code>$dumpvars</code> indicates which signals we see: 0 - see inputs
and outputs only, 1 - everything inside of the DUT, 2 - ??</p>
<h2 id="custom-instructions">Custom instructions</h2>
<h3 id="alu">ALU</h3>
<p>it is the heart of the microC</p>
<p>it receives two data (Ra, Rb) from the register-file and produces one
result (Rd) to the register-file.</p>
<p>The operation done is selected by the control signals (Cimm, Ccsel,
Cminus, Copp), that are set depending the instruction.</p>
<p>Note that only one operation can be selected, although all operations
are performed.</p>
<p>E.g. this line:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> <span class="op">(((</span>rgb565 <span class="op">&amp;</span> <span class="bn">0xF800</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">*</span> <span class="dv">5</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">4</span><span class="op">;</span></span></code></pre></div>
<p>would result in these operations in ALU:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>andi r5<span class="op">,</span>r5<span class="op">,</span><span class="bn">0xF800</span>     <span class="op">#</span> rgb565 <span class="op">&amp;</span> <span class="bn">0xF800</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>sri r5<span class="op">,</span>r5<span class="op">,</span><span class="dv">8</span>           <span class="op">#</span> <span class="op">(</span>rgb565 <span class="op">&amp;</span> <span class="bn">0xF800</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">8</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>muli r5<span class="op">,</span>r5<span class="op">,</span><span class="dv">5</span>          <span class="op">#</span> <span class="op">((</span>rgb565 <span class="op">&amp;</span> <span class="bn">0xF800</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>sri r5<span class="op">,</span>r5<span class="op">,</span><span class="dv">4</span>           <span class="op">#</span> <span class="op">(((</span>rgb565 <span class="op">&amp;</span> <span class="bn">0xF800</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">*</span> <span class="dv">5</span><span class="op">)</span> <span class="op">&gt;&gt;</span> <span class="dv">4</span></span></code></pre></div>
<p>However, in HW it’s way simpler: select wires for the first instr,
a*5 translate to a*2 + a (so only 10-bit adder), and then b&gt;&gt;4
which is just wiring.</p>
<h3 id="custom-instruction-hw-interface">Custom instruction hw
interface</h3>
<p>The minimal set of signals that the µC provides us with to create
custom instruction hardware is (note: input/output is from the
perspective of the µC):</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 6%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Direction</th>
<th>#bits</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ciStart</td>
<td>output</td>
<td>1</td>
<td>Indicates an active custom instruction</td>
</tr>
<tr class="even">
<td>ciN</td>
<td>output</td>
<td>8</td>
<td>The custom instruction identifier code.</td>
</tr>
<tr class="odd">
<td>ciDataA</td>
<td>output</td>
<td>32</td>
<td>The value of register A (Ra) going into the ALU/CI.</td>
</tr>
<tr class="even">
<td>ciDataB</td>
<td>output</td>
<td>32</td>
<td>The value of register B (Rb) going into the ALU/CI.</td>
</tr>
<tr class="odd">
<td>ciResult</td>
<td>input</td>
<td>32</td>
<td>The result value to be written to the register file (Rd).</td>
</tr>
<tr class="even">
<td>ciDone</td>
<td>input</td>
<td>1</td>
<td>The signal indicating that the CI performed it’s operation</td>
</tr>
</tbody>
</table>
<p>The <code>ciDone</code> signal is a very important signal. If the µC
activates a custom instruction by the <code>ciStart</code> signal it
will wait (stall) till an activation of the <code>ciDone</code>. If the
<code>ciDone</code> is not activated your system will
<strong>DEADLOCK</strong>!</p>
<p>The signal `ciN`` indicates which custom instruction is activated. As
this signal is 8-bit wide we can implement up to 256 custom
instructions.</p>
<h4 id="ci-example">ci example</h4>
<p>We can implement multiple custom instructions. Why not “multiplexing”
the ciDone and the ciResult signals by using the ciN signal?</p>
<p>Very simple: multiplexers have more logic as simple or-gates (or
and-gates, the alternative)…</p>
<p>This poses, however, some restrictions that we have to take into
account when designing a custom instruction module….</p>
<p>Timing requirements: assume that the custom instruction hw has the
custom instruction identifier 0x17.</p>
<p>When the <code>ciN</code> does not correspond to the custom
instruction identifier no <code>done</code> is generated.</p>
<p>If it does correspond, we can have a single-cycle or a multi-cycle
response (any number of cycles between the start and done). For example,
stall for some delay, and the ci will stall the CPU for specified number
of microseconds</p>
<blockquote>
<p>Note that in case of a multi-cycle response the µC is stalled!</p>
</blockquote>
<h3 id="custom-instruction-sw-interface">Custom instruction SW
interface</h3>
<p>To interact with the ci, we need to activate them with assembly
instruction, since compiler does not know it. E.g. (note that 0x17 is
the ci identifier):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint32_t</span> result<span class="op">,</span> regA<span class="op">,</span> regB<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>asm <span class="dt">volatile</span> <span class="op">(</span><span class="st">&quot;l.nios_rrr %[rd],%[ra],%[rb],0x17&quot;</span><span class="op">:[</span>rd<span class="op">]</span><span class="st">&quot;=r&quot;</span><span class="op">(</span>result<span class="op">):</span> <span class="op">[</span>ra<span class="op">]</span><span class="st">&quot;r&quot;</span><span class="op">(</span>regA<span class="op">),[</span>rb<span class="op">]</span><span class="st">&quot;r&quot;</span><span class="op">(</span>regB<span class="op">)</span> <span class="op">);</span></span></code></pre></div>
<p>Some variations:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ci with only inputs, e.g. for a flipflop outputs to another flipflop (this is defined in hw)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">// :: is required because after the first : are the registers that are written, and after the second : are the registers that are read</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>asm <span class="dt">volatile</span> <span class="op">(</span><span class="st">&quot;l.nios_rrr r0,%[ra],%[rb],0x1A&quot;</span><span class="op">::[</span>ra<span class="op">]</span><span class="st">&quot;r&quot;</span><span class="op">(</span>regA<span class="op">),[</span>rb<span class="op">]</span><span class="st">&quot;r&quot;</span><span class="op">(</span>regB<span class="op">)</span> <span class="op">);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ci with only an output, e.g. output of several chained flipflop</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">// second : is not required here</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>asm <span class="dt">volatile</span> <span class="op">(</span><span class="st">&quot;l.nios_rrr %[rd],r0,r0,0x72&quot;</span><span class="op">:[</span>rd<span class="op">]</span><span class="st">&quot;=r&quot;</span><span class="op">(</span>result<span class="op">)</span> <span class="op">);</span></span></code></pre></div>
<p><code>r0</code> is used as a replacement for <code>rd</code>, since
it is the dummy register in RISC arch (writing to it does nothing,
reading always gives 0)</p>
<p>Compiler looking into this code cannot infer if it can apply any
optimizations, since it does not know what it happening.</p>
<h4 id="ci-usage">ci Usage</h4>
<p>Example, for converting rgb to grayscale:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rgbToGrayscale<span class="op">(</span> <span class="dt">int</span> width<span class="op">,</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">int</span> height<span class="op">,</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">const</span> <span class="dt">uint32_t</span> <span class="op">*</span>rgb_source<span class="op">,</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                     <span class="dt">uint32_t</span> <span class="op">*</span>grayscale_destination <span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> loop<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">uint32_t</span> temp<span class="op">,</span> grayscale<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span>loop <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> loop <span class="op">&lt;</span> width<span class="op">*</span>height<span class="op">;</span> loop<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>      temp <span class="op">=</span> rgb_source<span class="op">[</span>loop<span class="op">]</span> <span class="op">&amp;</span> <span class="bn">0x3F</span><span class="op">;</span> <span class="co">// red value</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>      grayscale <span class="op">=</span> temp<span class="op">*</span><span class="dv">77</span><span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>      temp <span class="op">=</span> <span class="op">(</span>rgb_source<span class="op">[</span>loop<span class="op">]</span> <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">&amp;</span> <span class="bn">0x3F</span><span class="op">;</span> <span class="co">// green value</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>      grayscale <span class="op">+=</span> temp<span class="op">*</span><span class="dv">151</span><span class="op">;</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>      temp <span class="op">=</span> <span class="op">(</span>rgb_source<span class="op">[</span>loop<span class="op">]</span> <span class="op">&gt;&gt;</span> <span class="dv">16</span><span class="op">)</span> <span class="op">&amp;</span> <span class="bn">0x3F</span><span class="op">;</span> <span class="co">// blue value</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>      grayscale <span class="op">+=</span> temp<span class="op">*</span><span class="dv">28</span><span class="op">;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>      grayscale <span class="op">&amp;=</span> <span class="bn">0xFF00</span><span class="op">;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>      grayscale_destination<span class="op">[</span>loop<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>grayscale <span class="op">&lt;&lt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">|</span> grayscale <span class="op">|</span> <span class="op">(</span>grayscale <span class="op">&gt;&gt;</span> <span class="dv">8</span><span class="op">);</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is a lot of operations: mask, multiply, shift + mask, multiply
….</p>
<p>In DFG (data flow graph), we can group actions into groups:</p>
<ul>
<li>reading: software load of RGB-values</li>
<li>putting values into expected formats: shifting and masking has no
cost in hw (just wiring)</li>
<li>calculating grayscale: fixed coefficient multiplication of 8x6 bits
and addtition can be performed in less than 1 CPU clock cycle in hw</li>
<li>result value: shifting and formatting has no cost in hw (just
wiring)</li>
<li>storing: software store</li>
</ul>
<p>We reduce this algorithm to the: load, ci, store. And the speedup is
the number of instructions removed.</p>
<h3 id="profiling">Profiling</h3>
<p>Profiling is used to see the hotspots and see what the hw
enhancements influence is.</p>
<p>Examples of it is gprof of the GNU-tool-chain, or valgrind and
kcachegrind.</p>
<p>However these tools gives use just info on execution time, not the
limitations/hotspots due to hw.</p>
<h4 id="profiling-limitations">Profiling limitations</h4>
<p>Software:</p>
<ul>
<li>It requires representative data-sets to profile as:
<ol type="1">
<li>a given data-set might not trigger some parts of the code resulting
in improper profiling information</li>
<li>a given dataset might be a corner case only banging on one function
resulting in improper profiling info</li>
<li>in general: garbage-in =&gt; garbage-out</li>
</ol></li>
<li>Profiling should be performed on the target hw, as compilers
optimize different</li>
<li>the program should behave properly, e.g. profiling might be useless
due to the use of function pointers</li>
</ul>
<p>Hardware:</p>
<ul>
<li>If profiling is done on another architecture the results can be
bogus as it does not represent the dynamic behavior of the target
system.</li>
<li>Modeling of all parameters in the virtual prototype has to been done
correctly, otherwise the real SOC can behave completely different.</li>
</ul>
<h4 id="profiling-information">Profiling information</h4>
<ul>
<li>On fixed systems we are only interested in the number of cpu-cycles
burned, as we cannot change the underlying architecture.</li>
<li>This is very often accomplished by using performance counters.
Performance counters are hardware counters that count clock-cycles (your
I3/I5/i/ for example has such counters build in).</li>
<li>in SOC design we have the liberty to modify the arch and the sw</li>
<li>here we are often also interested in more hw speficific parameters
as:
<ul>
<li>bus occupation (natural bottleneck)</li>
<li>cpu stall cycles</li>
<li>cache hit/miss ratio</li>
<li>cache thrashing latencies</li>
</ul></li>
</ul>
<p>All of this can be accomplished with performance (hw) counters</p>
<h4 id="performance-counters-limitations">Performance counters
limitations</h4>
<p>Limited by the number of bits they have (hence the “time” they can
measure)</p>
<p>They take area on the FPGA, so usually you have two versions - with
and without perf counters</p>
<p>The hardware needs to be observable (as in our case where everything
is available in verilog) in many cases it is not the case as some parts
are provided as IP-cores, in which case the perf counters can use
“models”</p>
<p>sets of models known are: worst case, typical case, best case.</p>
<h2 id="timing-closure">Timing closure</h2>
<p>To get the system running at the required frequency we need to go
into the phase called <em>timing closure</em></p>
<h3 id="rtl-register-transfer-level-design">RTL (Register Transfer
Level) design</h3>
<p>To prevent gated clocks the flipflops are connected to the same clock
source.</p>
<p>We know that due to transistor capacitance all gates have a date
delay that causes hazards.</p>
<p>Hazard - change in level that are caused by time gate delays</p>
<p><strong>Critical path</strong> - longest combinational path between
two flipflops. We need to wait for critical path time to be sure on the
value and that we are not hitting on the hazard.</p>
<p>What happens with the clock line? There are 3k flipflops in the mc
and all are connected to one clock line &lt;- the clock line thus would
have a big capacitave load. The RTL-design method assumes that the
rising edgeg of the clock arrives at all flipflops at same time.</p>
<h4 id="avoiding-big-capacitive-load">Avoiding big capacitive load</h4>
<p>Use binary tree of inverters because they will reduce load on each
output. Howver what is the resul of this op?</p>
<p>We introduce at the flipflop level a clock-skew (can be positive or
negative) due to the fakc that not all inverters have the same delay and
line-length-mismatches</p>
<p>There is also jitter - due to temperature and other things transistor
flips back and forth.</p>
<p>To reduce jitter and skew we have clock tree in form of a H-tree
(fractal). Clock is inserted in the middle, and inverters are at the
split points, and at the leaf points the flipflops and memory is
connected.</p>
<h4 id="setup-and-hold">Setup and hold</h4>
<p>Flipflops particularity - output delay and setup-and-hold time.</p>
<p>Setup and hold time - in which the D-input needs to be kept stable
(otherwise the flipflop goes into meta stable state - oscilation, which
ends up into unknown state).</p>
<p>Problem this causes - finite state machine goes into a ghost state
and stays in the ghost state.</p>
<p>What could cause this condition (in relation to the clock time):</p>
<ol type="1">
<li>The path between two flipflops is too fast (race-condition)</li>
<li>The path is too slow (frequency cannot be met)</li>
</ol>
<h4 id="race-condition">Race condition</h4>
<p>Putting together, the uncertainty we have - 2 * skew + jitter</p>
<p>If the output of flipflop C changes before setup-time of flipflop B,
hence we have a functional error as the data is too early available.</p>
<p>The output of flipflop C changes during tDstable of flipflop B which
goes in meta stable state (Note that this situation will always happen
independent of the clock frequency!).</p>
<p>The problem can be solved by inserting a delay between the flipflops
C and B. We don’t have to do this ourselves because it is done by
synthesis tools</p>
<p>This does not prevent hazards but does not produce hazards</p>
<h4 id="timing-not-met">Timing not met</h4>
<p><span class="math inline">t_{p,clock} = t_{clock\_to\_output} +
t_{critical,max} + t_{setup} + t_{uncertainty}</span></p>
<p>We know that during the critical path time we may have hazards on the
D-input of flipflop C, and that the correct value is available after
<span class="math inline">t_{critical_path}</span>.</p>
<p>All timing analyzers are in cases: best, typical, and worst case.
These models are based on the distribution of produced chips.</p>
<p>Tools use worst case timing model so that it makes sure that it works
with the given frequency</p>
<p>Note that the synthesizer and/or P&amp;R-tool might insert in front
of the combinational logic some inverters to prevent flipflop C from
going into meta stable state due to <span
class="math inline">t_{Dstable}</span> violation caused by hazards!</p>
<p>Timing is not met when there exists at least one combinational logic
path with a <span class="math inline">t_{critical\_path} &gt;
t_{critical\_path,max}</span>.</p>
<h3 id="what-is-timing-closure">What is timing closure</h3>
<p>Process of getting all <span class="math inline">t_{critical\_paths}
&lt; t_{critical\_path,max}</span>.</p>
<p>But that’s not all, we have two more timings that need attention:</p>
<ol type="1">
<li>The latest arrival of an external input signal (tlai) to the
flipflop with respect to the positive clock edge. Peripherals that
receive signals outside of the chip</li>
<li>The latest arrival of the signal from a flipflop to the edge of the
package (tlao) with respect to the positive clock edge.</li>
</ol>
<p>It used to be 4ns to go from chip to off-chip and same vice-versa
=&gt; 8ns delay to go to chip.</p>
<p>These numbers depend on the chip pconnected to this one and are in
general more difficult to determine.</p>
<p>We need to specify input-output delays</p>
<h4 id="timing-closure-off-chip">Timing closure off-chip</h4>
<p><strong>If you go off-chip - you put a flipflop in-between, and same
vice-versa</strong></p>
<p>More in detail: The later aspect is “easily” solved by not using any
combinational logic between the input(s) and the fist flipflop(s) and no
combinational logic between the last flipflop(s) and the output(s).
<strong>This has the advantage that you do not have any hazards outside
of your chip (good thing!).</strong></p>
<p>However, this is not always possible, in this case more advanced
methods are required like:</p>
<ul>
<li>Usage of a PLL/DLL to synchronize the attached chip with yours
(think of DDR memory).</li>
<li>Adding extra delays in some of the outputs to meet external
timings.</li>
</ul>
<h4 id="how-to-reduce-critical-paths">How to reduce critical paths</h4>
<p>On-chip aspect synthesis tool is more intelligent.</p>
<p>Methods that the synthesizer does not know about:</p>
<ul>
<li><strong>Fine-grained paralyzing</strong></li>
<li><strong>Multi-cycling</strong></li>
<li><strong>Pipelining</strong></li>
</ul>
<h4 id="speeding-up-your-circuit">Speeding up your circuit</h4>
<p>Have: 4-bit carry-riplle adder (CRA)</p>
<p>Assume this adder is in the critical path.</p>
<p>The critical path from this adder goes from Cin through the and- and
or-gates up to Cout/S3 - the carry path</p>
<p>What are the speed-up methods:</p>
<ul>
<li>Trading-off bigger area/energy consumption against speed
<ul>
<li>This is an example of Fine-grained paralyzing</li>
<li>We cut circuit in the middle, and we calculate the top when the
carry is 1, and we calculate the top when the carry is 0. We select the
result with a multiplexer.</li>
<li>This circuit becomes carry select adder that is almost twice as fast
- single cycle 4-bits addition</li>
</ul></li>
<li>Trading-off time against speed
<ul>
<li>Example of pipelining</li>
<li>In this method we divide the critical path in 2 (or more) parts and
place a row of flipflops between the parts.</li>
<li>The advantage is that we can do a calculation each cycle.</li>
<li>However, we introduce latency, which could cause problems in case of
a feed-back loop (e.g. data dependencies)</li>
</ul></li>
<li>Trading-off latency (performance) against area
<ul>
<li>Example of multi-cycle operation</li>
<li>We calculate one bit per cycle. (Of course this has an impact on the
performance, as now the addition takes 4 cycles instead of a single
cycle.)</li>
<li>Very often we perform a radix-N multi-cycle operation where at each
cycle N-bits are determined.</li>
<li>Of course, when A and B are guaranteed to be constant between
<code>start</code> and <code>done</code>, we can replace the input
shift-registers by a multiplexer</li>
<li>This is nice for division because it is difficult - it is subraction
and dependance. On a 32-bit CPU using a library, we need 120 cycles for
Integer division.</li>
</ul></li>
</ul>
<h2 id="bus-architectures">Bus architectures</h2>
<p>It is used to exchange information from <em>master</em> device(s) to
<em>slave</em> device(s).</p>
<p>Information consists of:</p>
<ul>
<li>the memory address of the access</li>
<li>the type of access (read/write)</li>
<li>the data (to/from the master)</li>
<li>some handshake signals</li>
</ul>
<p>Therer are many ways how we can set-up this transfer of
information.</p>
<h3 id="simple-bus-architectures">Simple bus architectures</h3>
<figure>
<img src="../Images/ESD-simplebusarch.png" alt="Simple architecture" />
<figcaption aria-hidden="true">Simple architecture</figcaption>
</figure>
<p>This bus is working with a 74.25MHz clock.</p>
<p>There are OR-gates (sometimes realized with AND-gates), which is
typical for on-chip buses, as we do not apply tr-state (bi-directional)
buses as they are slow (tri-state capacitance, etc) and they may cause
short circuits if used improperly.</p>
<h4 id="signals-in-the-bus">Signals in the bus</h4>
<ul>
<li><strong>address_data</strong> : 32-bit channel that transports the
address or data.</li>
<li><strong>byte_enables</strong> : 4-bit channel that indicates in a
single transfer which bytes are valid.</li>
<li><strong>burst_size</strong> : 8-bit channel that indicates the
number of words to transfer (value+1).</li>
<li><strong>read_n_write</strong> : 1-bit channel indicates a read (when
1) or write transaction (when 0).</li>
<li><strong>begin_transaction</strong> : 1-bit channel that indicates
the beginning of a transaction.</li>
<li><strong>end_transaction</strong> : 1-bit channel that indicates the
end of a transaction.</li>
<li><strong>data_valid</strong> : 1-bit channel that indicates a valid
datum on the address_data lines.</li>
<li><strong>busy</strong> : 1-bit channel that indicates that the
receiver cannot process yet the datum.</li>
<li><strong>error</strong> : 1-bit channel that indicates a bus
error.</li>
</ul>
<p>All signals (50-bits) are active-high and should be forced to 0 when
not in use (due to the or-gates)</p>
<h4 id="write-transactions">Write transactions</h4>
<p>Single word transactions: at the begining of the transaction all
information is provided. In case of an “error” the master must end the
transaction. The minimal single word transaction time is 5
clock-cycles</p>
<p>Multiple words write transactions: the minimal time of the
transaction is 3+NrOfWords clock-cycles.</p>
<h5 id="read-transactions">Read transactions</h5>
<p>For single word read transactions: In case of an “error” the master
must end the transaction. Otherwise the slave ends the transaction. The
minimal single word transaction time is 5 clock-cycles</p>
<p>For multiple word read transactions they take the same amount of time
as write.</p>
<p>For multiple words read <strong>aborted</strong> transaction, in case
the error is detected the master must end the transaction. IF the slave
sees an end of transaction before the burst/single read is finished it
must end the ongoing transacttion and release the bus.</p>
<h3 id="crossbar-architectures">Crossbar architectures</h3>
<figure>
<img src="../Images/ESD-crossbararch.png" alt="Crossbar architecture" />
<figcaption aria-hidden="true">Crossbar architecture</figcaption>
</figure>
<p>There are many bus architectures, of which one example is this -
cross-bar (or sometimes called as point-to-point)</p>
</body>
</html>
